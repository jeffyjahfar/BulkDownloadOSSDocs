The (sdl *) Modules
1 Introduction
  1.1 Quick Start
  1.2 Naming Conventions
    1.2.1 Renaming C Functions
    1.2.2 Enums and Constants
    1.2.3 Create and Make
  1.3 Uniform Vectors
  1.4 Limitations
2 General SDL
3 Video
  3.1 Rectangles
  3.2 Colors
  3.3 Windowing System Interaction
  3.4 Surface
  3.5 Misc Surface Operations
4 Events
  4.1 Activity
  4.2 Keys
  4.3 Motions
  4.4 Buttons
  4.5 Joysticks
  4.6 Resizes
  4.7 Misc
5 Joystick
6 CDROM
7 OpenGL
8 TrueType
9 Audio
10 SDL_gfx by Andreas Schiffler
  10.1 Graphics Primitives
  10.2 Rotation / Zooming
  10.3 Managing Frame Rate
  10.4 RGBA Extras
  10.5 Image Filtering
11 Miscellaneous Utilities
12 Simple Closures
13 Excuses
  13.1 Categories
  13.2 Specific Notes
Appendix A Stashes
Appendix B GNU Free Documentation License
Index
The (sdl *) Modules
*******************

This manual documents Guile-SDL 0.5.2, a package which provides the
modules ‘(sdl sdl)’, ‘(sdl gfx)’, ‘(sdl ttf)’ and ‘(sdl mixer)’ for use
in Guile Scheme programs.  These modules wrap the Simple Direct Media
Layer(1) libraries on your system.  Additionally, experimental
abstractions and convenience procedures are provided in the modules
‘(sdl misc-utils)’ and ‘(sdl simple)’.

This manual is
Copyright © 2003–2015 Thien-Thi Nguyen

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with no Front-Cover Texts,
     and with no Back-Cover Texts.  A copy of the license is included in
     the appendix entitled “GNU Free Documentation License”.

   ---------- Footnotes ----------

   (1) The SDL homepage is <http://www.libsdl.org>.

1 Introduction
**************

The (sdl *) modules are an interface to the SDL (Simple Direct Media
Layer) library.  The goal is to provide both a clean and direct
interface to the lowest level SDL, while extending with higher level
concepts where useful, such as default arguments and functional-style
application of graphics routines.  Several SDL add-on libraries have
been wrapped and included with Guile-SDL, including SDL_image (for
loading multiple image formats), SDL_ttf (for rendering true type
fonts), SDL_mixer (for playing/mixing different audio formats), and
SDL_rotozoom (for rotating and scaling images).  In addition, some
low-level 2D graphics primitives have been provided.

1.1 Quick Start
===============

To whet your appetite, and hopefully get you excited about the ease and
flexibility of programming with Guile-SDL, we begin with a simple
example.  The following program is a simple image browser.  You can
cycle through images by using space, n or right to go forward,
backspace, p or left to go backwards, and escape or q to quit.

     ;; load the SDL module and some useful srfi's
     (use-modules ((sdl sdl) #:prefix SDL:)
                  (srfi srfi-1)
                  (srfi srfi-2))

     ;; initialize the video subsystem
     (SDL:init 'video)

     ;; directory to search for images in
     (define image-dir "/usr/share/pixmaps/")

     ;; utility to test if a path is a directory
     (define (file? f)
       (let* ((stats (stat f))
              (type (stat:type stats)))
         (eq? type 'regular)))

     ;; build a ring of image file names
     (define image-ring
       (let ((dir (opendir image-dir)))
         (letrec ((D (lambda (ls)
                       (let ((file (readdir dir)))
                         (if (eof-object? file)
                             (begin (closedir dir) ls)
                             (D (cons (string-append image-dir file)
                                      ls)))))))
           (apply circular-list (reverse (filter file? (D '())))))))

     ;; functions to cycle through the ring
     (define (next-image)
       (let ((next (car image-ring)))
         (set! image-ring (cdr image-ring))
         next))

     (define (prev-image)
       (let ((orig image-ring))
         (while (not (eq? (cddr image-ring) orig))
           (set! image-ring (cdr image-ring)))
         (let ((image (car image-ring)))
           (set! image-ring (cdr image-ring))
           image)))

     ;; display an image given a filename
     (define (show file)
       (and-let* ((image (SDL:load-image file)))
         (SDL:set-video-mode (SDL:surface:w image) (SDL:surface:h image) 24)
         (SDL:blit-surface image)
         (SDL:flip)))

     ;; show the first image
     (show (next-image))

     ;; event handler
     (let handle ((e (SDL:make-event)))
       (if (SDL:wait-event e)
         (case (SDL:event:type e)
           ((key-down)
            (case (SDL:event:key:keysym:sym e)
              ((left backspace)
               (show (prev-image)))
              ((right space)
               (show (next-image)))
              ((escape q)
               (SDL:quit)
               (quit))))))
       (handle e))

1.2 Naming Conventions
======================

The most important thing to learning a wrapped library for a programming
language, assuming you know the language and the library, is to know the
naming conventions.  Then you can begin programming without having to
look up the exact function reference (available in the rest of this
document).

1.2.1 Renaming C Functions
--------------------------

As with standard guile naming conventions, all names are converted to
lower-case, and underscores are replaced with hyphens.  Functions that
modify one or more arguments have an exclamation point (‘!’) appended,
and functions which ask a question and return a boolean value have a
question mark (‘?’) appended.

1.2.2 Enums and Constants
-------------------------

SDL enumerated types and constants are passed and returned as symbols,
thus enforcing their "constant" nature and for ease of use in ‘case’
statements.  Flags, such as the SDL initialization flags and video
surface flags, are treated as lists of symbols, each constant in the
flag group that you would ‘or’ together in C code becoming a symbol in
the list.

Some of these symbols retain their exact C names, while others are
adapted to better fit Scheme (mostly by removing the ‘SDL_’ prefix,
changing underscores to hyphens, downcasing, and inserting a hyphen
between “words”).

A particular set of enums is called an "enumstash".  Likewise
"flagstash" for flags.

You can use ‘kotk’ to examine the enums and flags encapsulated by these
respectively typed objects.  You can also use integers where enums/flags
are expected, and can convert between the symbol and numeric value with
‘enum->number’, ‘number->enum’, ‘flags->number’ and ‘number->flags’.

The conversion procs all take STASH as the first argument, a symbol that
identifies the particular set of enums/flags.  For backward
compatibility, STASH may also be such an object, but this support *will
be removed* after 2013-12-31, when those objects are to be fully
internalized.

 -- Procedure: kotk [name]
     Return the contents of stash NAME (a symbol), as an alist with
     symbolic keys, integer values.  If NAME is omitted, the keys are
     the names of the all the enum- and flagstashes, and the values have
     the form:

          (N TYPE)

     where N is the count of symbols in that stash, and TYPE is a
     symbol: ‘enums’ or ‘flags’.

 -- Procedure: enum->number stash symbol
     Return the number in STASH associated with SYMBOL.

 -- Procedure: number->enum stash number
     Return the symbol associated with NUMBER, or ‘#f’ if it does not
     belong to STASH.

 -- Procedure: flags->number stash flags
     Use STASH to convert FLAGS to a number.  FLAGS is a list of
     symbols; or ‘#f’, which is taken as the empty list; or ‘#t’, which
     is taken as the list of all possible symbols in STASH.

 -- Procedure: number->flags stash number
     Use STASH to convert NUMBER to a list of symbols.  If the flags in
     STASH are not sufficient to decode NUMBER, the first element of the
     list is the numeric remainder.

Conversion from symbols to numbers (including ‘enum->number’ and
‘flags->number’) throws an error with key ‘non-member-symbol’ if the
specified symbol is not a member of the respective enumstash or
flagstash.

1.2.3 Create and Make
---------------------

The standard SDL prefix for creating a new instance of a type is
‘create’.  The standard Guile prefix is ‘make’.  Wherever an SDL
function uses the ‘create’ prefix we will keep it.  Object creation
functions unique to Guile, such as ‘make-rect’, will use ‘make’ as a
prefix.  In addition, we will sometimes introduce higher-level creation
functions, such as ‘make-surface’, which is a wrapper to
‘create-rgb-surface’ which provides useful default values from the
current screen information.

1.3 Uniform Vectors
===================

Some procedures take one or more "uniform vector" arguments, as
specified in SRFI 4 (*note Video::, *note SDL_gfx::).  The specific type
of vector is one of ‘u8’, ‘u16’, ‘s16’, where ‘u’ or ‘s’ stands for
“unsigned” or “signed”, respectively, and the rest the number of bits.

1.4 Limitations
===============

There are some known problems with Guile-SDL modules.  This section
attempts to make them well-known, if not well-liked...

   • API in flux

     Since Guile-SDL is in alpha stage, its interfaces are not stable.
     Specifically, module names, the contents of modules, procedure
     names, procedure behavior: all these can change at any time up
     until the 1.0 release.  C’est la vie.

   • no logo

     How can any self-respecting package of bindings for libsdl not have
     a flashy, animated logo?  Bonus points for suitable accompanying
     sound blurb.

   • threading picture unclear

     Where do threads fit in if at all?  Why doesn’t the Guile-SDL
     maintainer learn all about threads, fix guile-1.4.x to support that
     and then arrange for Guile-SDL to DTRT? Questions questions...

   • [your gripes here]

2 General SDL
*************

 -- Procedure: init sel
     Initialize SDL and the subsystems/configuration represented by SEL
     (*note init flags::).

 -- Procedure: init-subsystem sel
     Initialize the SDL subsystems represented by SEL.  SEL is a list of
     flags (symbols) from the same set useful for ‘init’.

 -- Procedure: quit
     Shut down all SDL subsystems.  Return ‘#t’.

 -- Procedure: quit-subsystem sel
     Shut down the SDL subsystems represented by SEL.  SEL is a list of
     flags (symbols) from the same set useful for ‘init’.  Return ‘#t’.

 -- Procedure: was-init sel
     Check if the SDL subsystems represented by SEL have been
     initialized.  SEL is a list of flags (symbols) from the same set
     useful for ‘init’.  Return a list likewise composed.

 -- Procedure: get-ticks
     Return the number of milliseconds since the SDL library
     initialization.

 -- Procedure: delay ms
     Wait MS milliseconds.

 -- Procedure: get-error
     Return the current SDL error string.

3 Video
*******

 -- Procedure: create-cursor data mask w h x y
     Return a new cursor from DATA and MASK (both u8 uniform vectors),
     sized W by H and with hot pixel located at X,Y.

 -- Procedure: create-yuv-overlay width height format [display]
     Create a new YUV overlay, sized WIDTH by HEIGHT with overlay FORMAT
     (a symbol or an exact number).  Optional arg DISPLAY specifies a
     surface to use instead of creating a new one.

 -- Procedure: get-video-surface
     Return the current display surface.

 -- Procedure: video-cmf
     Return information about the video hardware as three values:
     ‘capabilities’ (list of symbols), ‘memory’ (integer), and ‘format’
     (pixel format object).  The ‘capabilities’ are:

          hw-available
          wm-available
          blit-hw   blit-hw-CC   blit-hw-A
          blit-sw   blit-sw-CC   blit-sw-A
          blit-fill

 -- Procedure: video-driver-name
     Return the name of the video driver.

 -- Procedure: list-modes [format [flags]]
     Return a list of available screen dimensions for pixel FORMAT and
     FLAGS (*note video flags::).  Format defaults to that for the
     current screen.  Flags default to none.  Return ‘#f’ if no modes
     are available, ‘#t’ if all are available.

 -- Procedure: video-mode-ok width height bpp [flags]
     Check to see if a particular video mode is supported.  Args are
     WIDTH, HEIGHT, BPP (numbers), and FLAGS (*note video flags::).
     Return ‘#f’ if the mode is not supported, or a number indicating
     the bits-per-pixel of the closest available mode supporting WIDTH
     and HEIGHT.

 -- Procedure: set-video-mode width height bpp [flags]
     Set the SDL video mode with WIDTH, HEIGHT and bits-per-pixel BPP.
     Optional arg FLAGS (*note video flags::) is supported.  Return a
     new surface.

3.1 Rectangles
==============

 -- Procedure: rect? obj
     Return ‘#t’ iff OBJ is an SDL-rectangle object.

 -- Procedure: make-rect x y width height
     Return a rectangle object with location X,Y and dimensions WIDTH by
     HEIGHT.

 -- Procedure: rect:x rect
     Get ‘x’ from RECT.

 -- Procedure: rect:y rect
     Get ‘y’ from RECT.

 -- Procedure: rect:w rect
     Get ‘w’ from RECT.

 -- Procedure: rect:h rect
     Get ‘h’ from RECT.

 -- Procedure: rect:set-x! rect value
     Set ‘x’ in RECT to VALUE.

 -- Procedure: rect:set-y! rect value
     Set ‘y’ in RECT to VALUE.

 -- Procedure: rect:set-w! rect value
     Set ‘w’ in RECT to VALUE.

 -- Procedure: rect:set-h! rect value
     Set ‘h’ in RECT to VALUE.

 -- Procedure: update-rect surface x [y [w [h]]]
     Update SURFACE within a specified rectangle.  The second arg can
     either be an SDL-Rect object, or the second through fifth args are
     numbers specifying the x, y, width and height of a rectangular
     area.

 -- Procedure: update-rects surface ls
     On SURFACE, update the rectangles in LS, a list of rectangles.

 -- Procedure: flip [surface]
     Swap double buffers of the default surface, or of SURFACE if
     specified.

3.2 Colors
==========

 -- Procedure: color? obj
     Return ‘#t’ iff OBJ is an SDL-Color object.

 -- Procedure: make-color r g b
     Return a color object with R, G, and B components.

 -- Procedure: color:r color
     Get ‘r’ from COLOR.

 -- Procedure: color:g color
     Get ‘g’ from COLOR.

 -- Procedure: color:b color
     Get ‘b’ from COLOR.

 -- Procedure: color:set-r! color value
     Set ‘r’ in COLOR to VALUE.

 -- Procedure: color:set-g! color value
     Set ‘g’ in COLOR to VALUE.

 -- Procedure: color:set-b! color value
     Set ‘b’ in COLOR to VALUE.

 -- Procedure: set-colors! surface colors [start]
     Set a portion of the colormap for the 8-bit SURFACE using COLORS, a
     vector of SDL-Colors.  Optional arg START (an integer in the range
     [0,255]) specifies the portion to be modified.  It defaults to 0.

 -- Procedure: set-palette surface flags colors [start]
     Set the palette of an 8-bit SURFACE using FLAGS (*note palette
     flags::) and COLORS, a vector of SDL-Colors.  Optional arg START
     (an integer in the range [0,255]) specifies the portion to be
     modified.  It defaults to 0.

 -- Procedure: set-gamma redgamma greengamma bluegamma
     Set the color gamma function for the display using real numbers
     REDGAMMA, GREENGAMMA and BLUEGAMMA.

 -- Procedure: get-gamma-ramp
     Return the gamma translation lookup tables currently used by the
     display as a list of three tables, for red, green and blue.  Each
     table is a u16 uniform vector of length 256.  Return ‘#f’ if
     unsuccessful.

 -- Procedure: set-gamma-ramp r g b
     Set the gamma translation lookup tables currently used by the
     display to tables R, G and B, each a u16 uniform vector of length
     256, or ‘#f’, in which case that particular component is unchanged.
     Return ‘#t’ if successful.

 -- Procedure: map-rgb format r [g [b]]
     Map a RGB color value to the pixel FORMAT.  The second arg can be
     an SDL-Color, otherwise the second through fourth args are red,
     green and blue values (numbers).  Return the mapped components as
     an unsigned integer.

 -- Procedure: map-rgba format r g [b [a]]
     Map a RGB color value to the pixel FORMAT.  If the second arg is an
     SDL-Color, the third is an alpha value (number).  Otherwise, the
     second through fifth args are red, green, blue and alpha values
     (numbers).  Return the mapped components as an unsigned integer.

 -- Procedure: pixel-rgb pixel format
     Return RGB info from PIXEL in the specified pixel FORMAT as three
     values: ‘r’, ‘g’ and ‘b’ (all integers).

 -- Procedure: pixel-rgba pixel format
     Return RGBA info from PIXEL in the specified pixel FORMAT as four
     values: ‘r’, ‘g’, ‘b’ and ‘a’ (all integers).

 -- Procedure: fill-rect surface rect color
     Fill SURFACE RECT with COLOR (a number).  If RECT is ‘#f’, fill the
     entire surface.  Return ‘#t’ if successful.

 -- Procedure: display-format surface
     Return a new surface made by converting SURFACE to the display
     format.  Return ‘#f’ if not successful.

 -- Procedure: display-format-alpha surface
     Return a new surface made by converting SURFACE to the display
     format, with an alpha channel.  Return ‘#f’ if not successful.

 -- Procedure: warp-mouse x y
     Set the position of the mouse cursor to X,Y.

 -- Procedure: set-cursor cursor
     Set the current mouse cursor to CURSOR.

 -- Procedure: get-cursor
     Get the current mouse cursor.

 -- Procedure: show-cursor [setting]
     Return the current visibility of the pointer (aka “mouse cursor”)
     as a boolean.  If arg SETTING (a boolean) is specified, set the
     visibility to SETTING (the returned visibility corresponds to that
     before the call, regardless).

 -- Procedure: gl-get-attribute attribute
     Return the value of a special SDL/OpenGL ATTRIBUTE.

 -- Procedure: gl-set-attribute attribute value
     Set the special SDL/OpenGL ATTRIBUTE to VALUE.  Both args are
     numbers.

 -- Procedure: gl-swap-buffers
     Swap OpenGL framebuffers/Update Display.

 -- Procedure: lock-yuv-overlay overlay
     Lock the given YUV OVERLAY.  Return ‘#f’ if successful.

 -- Procedure: unlock-yuv-overlay overlay
     Unlock the previously locked YUV OVERLAY.

 -- Procedure: display-yuv-overlay overlay dstrect
     Blit the YUV OVERLAY to the display DSTRECT over which it was
     created.  Return ‘#t’ if successful.

3.3 Windowing System Interaction
================================

 -- Procedure: get-wm-info
     Return information on the window manager, as a list of the form:
     (VERSION SUBSYSTEM DISPLAY WINDOW FSWINDOW WMWINDOW). VERSION is a
     sub-list of form: (MAJOR MINOR PATCH), where element is an integer.
     SUBSYSTEM is either the symbol ‘x11’, or ‘#f’.  DISPLAY is a
     pointer (machine address) of the X11 Display structure, converted
     to an integer.  WINDOW, FSWINDOW and WMWINDOW are Window
     identifiers (also integers).

 -- Procedure: set-caption title [icon]
     Set the title-bar and icon name of the display window to TITLE and
     ICON (both strings), respectively.  If ICON is not specified, use
     TITLE by default.

 -- Procedure: caption-ti
     Return display-window caption as two values: ‘title’ and ‘icon’
     (both strings, or ‘#f’ if not set).

 -- Procedure: set-icon icon
     Set ICON for the display window.

 -- Procedure: iconify-window
     Iconify/Minimize the window.  Return ‘#t’ if successful.

 -- Procedure: toggle-full-screen [surface]
     Toggle the default video surface between windowed and fullscreen
     mode, if supported.  Optional arg SURFACE specifies another surface
     to toggle.  Return ‘#t’ if successful.

 -- Procedure: grab-input [mode]
     Grab mouse and keyboard input.  Return new grab state.  Optional
     arg MODE (a symbol) specifies the kind of grab, one of ‘query’ (the
     default), ‘off’ or ‘on’.

 -- Procedure: get-app-state
     Return the current state of the application, a list of symbols.
     The list may include: ‘mousefocus’, ‘inputfocus’, ‘active’.

3.4 Surface
===========

 -- Procedure: make-surface width height [flags]
     Return a new surface of dimensions WIDTH by HEIGHT.  Optional third
     arg FLAGS (*note video flags::) further specifies the surface.
     Color depth and masks are those for the current video surface.

 -- Procedure: create-rgb-surface flags width height depth rmask gmask
          bmask amask
     Return an empty surface.  The eight arguments, directly analagous
     to those for SDL_CreateRGBSurface, are: FLAGS (list of symbols,
     *note video flags::), WIDTH, HEIGHT, DEPTH, RMASK, GMASK, BMASK,
     AMASK (all numbers).

 -- Procedure: surface:w surface
     Get ‘w’ from SURFACE.

 -- Procedure: surface:h surface
     Get ‘h’ from SURFACE.

 -- Procedure: surface:depth surface
     Get ‘format->BitsPerPixel’ from SURFACE.

 -- Procedure: surface:flags surface
     Return ‘flags’ from SURFACE as a (possibly empty) list of symbols.

 -- Procedure: surface-get-format surface
     Return a new pixel format, the same used by SURFACE.

 -- Procedure: surface? obj
     Return true iff OBJ is a surface.

 -- Procedure: lock-surface surface
     Lock SURFACE for direct access.  Return ‘#t’ if successful.

 -- Procedure: unlock-surface surface
     Unlock previously locked SURFACE.

 -- Procedure: load-bmp filename
     Load bitmap data from FILENAME.  Return a new surface if
     successful, otherwise ‘#f’.

 -- Procedure: load-image filename
     Load image data from FILENAME.  Return a new surface if successful,
     otherwise ‘#f’.

 -- Procedure: save-bmp surface filename
     Save SURFACE to FILENAME in Windows BMP format.  Return ‘#t’ if
     successful.

 -- Procedure: surface-color-key! surface pixel [rle]
     Set the color key for SURFACE to PIXEL.  If PIXEL is ‘#f’, clear
     the current color key.  Otherwise, it should be an integer of the
     appropriate depth for SURFACE (e.g., in the range [0,65535] for 16
     bpp).  If color key processing is enabled, optional arg RLE is a
     boolean that enables (true) or disables (false, the default) RLE
     acceleration.  Return ‘#t’ if successful.

 -- Procedure: surface-alpha! surface alpha [rle]
     Set alpha blending for the entire SURFACE to ALPHA.  If ALPHA is
     ‘#f’, disable alpha blending.  Otherwise it should be an integer in
     the range [0,255] or one of the symbols ‘transparent’ or ‘opaque’.
     If alpha blending is enabled, optional arg RLE is a boolean that
     enables (true) or disables (false, the default) RLE acceleration.
     Return ‘#t’ if successful.

 -- Procedure: set-clip-rect! surface [rect]
     Set SURFACE clipping rectangle to the whole surface.  Optional arg
     RECT, if non-‘#f’, specifies a particular rectangle instead of
     using the whole surface.

 -- Procedure: get-clip-rect surface
     Return the clipping rectangle for SURFACE.

 -- Procedure: convert-surface surface format [flags]
     Convert SURFACE to the same FORMAT as another surface.  Optional
     third arg FLAGS is a list of flags (*note video flags::).

 -- Procedure: blit-surface src [srcrect [dst [dstrect]]]
     Perform a fast blit from the SRC surface SRCRECT to the DST surface
     DSTRECT.  SRCRECT defaults to x=0, y=0, SRC surface dimensions.  If
     unspecified DST is taken as the default video surface.  DSTRECT
     likewise defaults to x=0, y=0, DST surface dimensions.

3.5 Misc Surface Operations
===========================

 -- Procedure: vertical-flip-surface surface
     Return a new surface created by flipping SURFACE vertically.

 -- Procedure: horizontal-flip-surface surface
     Return a new surface created by flipping SURFACE horizontally.

 -- Procedure: vh-flip-surface surface
     Return a new surface created by flipping SURFACE both vertically
     and horizontally.

 -- Procedure: surface-pixels surface [squash]
     Return pixel data of SURFACE as a new uniform vector.  The uvec has
     type ‘u8’, ‘u16’ or ‘u32’, corresponding to the SURFACE depth, with
     HEIGHT x WIDTH elements.  A 24bpp surface — DEPTH-IN-BYTES of 3 —
     is expanded (per pixel) to ‘u32’, leaving the high nybble clear.

     Optional arg SQUASH non-‘#f’ means to return a u8vector regardless
     of SURFACE depth, with HEIGHT x WIDTH x DEPTH-IN-BYTES elements.

4 Events
********

 -- Procedure: make-event [type]
     Return a new SDL event.  Optional arg TYPE is a symbol (*note
     event-type enums::).  If omitted, the default is ‘SDL_NOEVENT’.

 -- Procedure: event:type event
     Return the symbolic ‘type’ from EVENT.

 -- Procedure: event:set-type! event value
     Set ‘type’ in EVENT to VALUE, a symbol or integer.

4.1 Activity
============

The value for ‘event:active:gain’ and ‘event:active:set-gain!’ is a
symbol, one of: ‘gained’ or ‘lost’.

The value for ‘event:active:state’ and ‘event:active:set-state!’ is a
(possibly empty) list of symbols from the same set used by
‘get-app-state’.

 -- Procedure: event:active:gain event
     Return the symbolic ‘active.gain’ from EVENT.

 -- Procedure: event:active:state event
     Return ‘active.state’ from EVENT as a (possibly empty) list of
     symbols.

 -- Procedure: event:active:set-gain! event value
     Set ‘active.gain’ in EVENT to VALUE, a symbol or integer.

 -- Procedure: event:active:set-state! event value
     Set ‘active.state’ in EVENT to VALUE, a (possibly empty) list of
     symbols.

4.2 Keys
========

The value for ‘event:key:state’ and ‘event:key:set-state!’ is a symbol,
one of: ‘released’ or ‘pressed’.

 -- Procedure: event:key:keysym:sym event
     Return the symbolic ‘key.keysym.sym’ from EVENT.

 -- Procedure: event:key:keysym:set-sym! event value
     Set ‘key.keysym.sym’ in EVENT to VALUE, a symbol or integer.

 -- Procedure: event:key:keysym:mod event
     Return ‘key.keysym.mod’ from EVENT as a (possibly empty) list of
     symbols.

 -- Procedure: event:key:keysym:set-mod! event value
     Set ‘key.keysym.mod’ in EVENT to VALUE, a (possibly empty) list of
     symbols.

 -- Procedure: event:key:state event
     Return the symbolic ‘key.state’ from EVENT.

 -- Procedure: event:key:keysym:scancode event
     Get ‘key.keysym.scancode’ from EVENT.

 -- Procedure: event:key:keysym:unicode event
     Get ‘key.keysym.unicode’ from EVENT.

 -- Procedure: event:key:set-state! event value
     Set ‘key.state’ in EVENT to VALUE, a symbol or integer.

 -- Procedure: event:key:keysym:set-scancode! event value
     Set ‘key.keysym.scancode’ in EVENT to VALUE.

 -- Procedure: event:key:keysym:set-unicode! event value
     Set ‘key.keysym.unicode’ in EVENT to VALUE.

4.3 Motions
===========

 -- Procedure: event:motion:state event
     Return ‘motion.state’ from EVENT as a (possibly empty) list of
     symbols.

 -- Procedure: event:motion:x event
     Get ‘motion.x’ from EVENT.

 -- Procedure: event:motion:y event
     Get ‘motion.y’ from EVENT.

 -- Procedure: event:motion:xrel event
     Get ‘motion.xrel’ from EVENT.

 -- Procedure: event:motion:yrel event
     Get ‘motion.yrel’ from EVENT.

 -- Procedure: event:motion:set-state! event value
     Set ‘motion.state’ in EVENT to VALUE, a (possibly empty) list of
     symbols.

 -- Procedure: event:motion:set-x! event value
     Set ‘motion.x’ in EVENT to VALUE.

 -- Procedure: event:motion:set-y! event value
     Set ‘motion.y’ in EVENT to VALUE.

 -- Procedure: event:motion:set-xrel! event value
     Set ‘motion.xrel’ in EVENT to VALUE.

 -- Procedure: event:motion:set-yrel! event value
     Set ‘motion.yrel’ in EVENT to VALUE.

4.4 Buttons
===========

The value for ‘event:button:button’ and ‘event:button:set-button!’ is a
(possibly empty) list of symbols from the set:

     left middle right
     wheel-up wheel-down
     x1 x2

The value for ‘event:button:state’ and ‘event:button:set-state!’ is a
symbol, one of: ‘released’ or ‘pressed’.

 -- Procedure: event:button:button event
     Return the symbolic ‘button.button’ from EVENT.

 -- Procedure: event:button:state event
     Return the symbolic ‘button.state’ from EVENT.

 -- Procedure: event:button:x event
     Get ‘button.x’ from EVENT.

 -- Procedure: event:button:y event
     Get ‘button.y’ from EVENT.

 -- Procedure: event:button:set-button! event value
     Set ‘button.button’ in EVENT to VALUE, a symbol or integer.

 -- Procedure: event:button:set-state! event value
     Set ‘button.state’ in EVENT to VALUE, a symbol or integer.

 -- Procedure: event:button:set-x! event value
     Set ‘button.x’ in EVENT to VALUE.

 -- Procedure: event:button:set-y! event value
     Set ‘button.y’ in EVENT to VALUE.

4.5 Joysticks
=============

The value for ‘event:jbutton:state’ and ‘event:jbutton:set-state!’ is a
symbol, one of: ‘released’ or ‘pressed’.

The value for ‘event:jhat:value’ and ‘event:jhat:set-value!’ is a list
of or more symbols from the set:

     centered
     up    down
     left  right

Specifying the empty list for ‘event:jhat:set-value!’ is effectively the
same as specifying ‘centered’.

 -- Procedure: event:jaxis:which event
     Get ‘jaxis.which’ from EVENT.

 -- Procedure: event:jaxis:axis event
     Get ‘jaxis.axis’ from EVENT.

 -- Procedure: event:jaxis:value event
     Get ‘jaxis.value’ from EVENT.

 -- Procedure: event:jaxis:set-which! event value
     Set ‘jaxis.which’ in EVENT to VALUE.

 -- Procedure: event:jaxis:set-axis! event value
     Set ‘jaxis.axis’ in EVENT to VALUE.

 -- Procedure: event:jaxis:set-value! event value
     Set ‘jaxis.value’ in EVENT to VALUE.

 -- Procedure: event:jbutton:which event
     Get ‘jbutton.which’ from EVENT.

 -- Procedure: event:jbutton:button event
     Get ‘jbutton.button’ from EVENT.

 -- Procedure: event:jbutton:state event
     Return the symbolic ‘jbutton.state’ from EVENT.

 -- Procedure: event:jbutton:set-which! event value
     Set ‘jbutton.which’ in EVENT to VALUE.

 -- Procedure: event:jbutton:set-button! event value
     Set ‘jbutton.button’ in EVENT to VALUE.

 -- Procedure: event:jbutton:set-state! event value
     Set ‘jbutton.state’ in EVENT to VALUE, a symbol or integer.

 -- Procedure: event:jball:which event
     Get ‘jball.which’ from EVENT.

 -- Procedure: event:jball:ball event
     Get ‘jball.ball’ from EVENT.

 -- Procedure: event:jball:xrel event
     Get ‘jball.xrel’ from EVENT.

 -- Procedure: event:jball:yrel event
     Get ‘jball.yrel’ from EVENT.

 -- Procedure: event:jball:set-which! event value
     Set ‘jball.which’ in EVENT to VALUE.

 -- Procedure: event:jball:set-ball! event value
     Set ‘jball.ball’ in EVENT to VALUE.

 -- Procedure: event:jball:set-xrel! event value
     Set ‘jball.xrel’ in EVENT to VALUE.

 -- Procedure: event:jball:set-yrel! event value
     Set ‘jball.yrel’ in EVENT to VALUE.

 -- Procedure: event:jhat:which event
     Get ‘jhat.which’ from EVENT.

 -- Procedure: event:jhat:hat event
     Get ‘jhat.hat’ from EVENT.

 -- Procedure: event:jhat:value event
     Return ‘jhat.value’ from EVENT as a (possibly empty) list of
     symbols.

 -- Procedure: event:jhat:set-which! event value
     Set ‘jhat.which’ in EVENT to VALUE.

 -- Procedure: event:jhat:set-hat! event value
     Set ‘jhat.hat’ in EVENT to VALUE.

 -- Procedure: event:jhat:set-value! event value
     Set ‘jhat.value’ in EVENT to VALUE, a (possibly empty) list of
     symbols.

4.6 Resizes
===========

 -- Procedure: event:resize:w event
     Get ‘resize.w’ from EVENT.

 -- Procedure: event:resize:h event
     Get ‘resize.h’ from EVENT.

 -- Procedure: event:resize:set-w! event value
     Set ‘resize.w’ in EVENT to VALUE.

 -- Procedure: event:resize:set-h! event value
     Set ‘resize.h’ in EVENT to VALUE.

4.7 Misc
========

 -- Procedure: pump-events
     Gather events from input devices and update the event queue.

 -- Procedure: evqueue-add [events…]
     Add ‘events’ to the back of the event queue.  Return the count of
     succesfully added events.

 -- Procedure: evqueue-peek n mask [accumulate]
     Return a count (less than or equal to N) of events at the front of
     the event queue that match MASK, without changing the queue.
     Optional arg ACCUMULATE if non-‘#f’ means to return the list of
     matched events, instead.  If there are errors, return ‘#f’.

     *Note event-mask flags::.

 -- Procedure: evqueue-get n mask
     Return a list (of length at most N) of events at the front of the
     event queue that match MASK, removing them from the queue.  If
     there are errors, return ‘#f’.

     *Note event-mask flags::.

 -- Procedure: poll-event [event]
     Poll for events and return ‘#t’ if there are any pending.  Optional
     arg EVENT specifies an event object (from ‘make-event’) to be
     filled in with the next event from the queue (if available).

 -- Procedure: wait-event [event]
     Wait indefinitely for and return ‘#f’ only if there were errors.
     Optional arg EVENT specifies an event object (from ‘make-event’) to
     be filled in with the next event from the queue.

 -- Procedure: push-event event
     Push EVENT onto the queue.  Return ‘#t’ on success.

 -- Procedure: set-event-filter filter full?
     Set the event filter to FILTER, or clear it if FILTER is ‘#f’.
     This is a procedure called with one arg, and whose return value, if
     non-‘#f’, means to keep the event, otherwise discard it.  If FULL?
     is ‘#f’, the arg the event type (a symbol), otherwise it is an
     event object.

 -- Procedure: get-event-filter
     Return information on the current event filter, or ‘#f’ if none is
     set.  If there is a filter, the value is a pair with car the filter
     proc, and cdr ‘#f’ if the proc takes an event type, or ‘#t’ if the
     proc takes an event object.

 -- Procedure: event-type-handling type [setting]
     Return ‘#t’ if event TYPE (*note event-type enums::) is recognized
     and queued, or ‘#f’ if it is ignored.  If SETTING is specified, set
     the handling of TYPE to the truth value of SETTING first.

 -- Procedure: enable-unicode [enable-p]
     Return ‘#t’ iff UNICODE keyboard translation is enabled.  Optional
     arg ENABLE? if non-‘#f’, enables UNICODE keyboard translation, or
     disables it if ‘#f’.

 -- Procedure: enable-key-repeat delay interval
     Enable or disable keyboard repeat.  DELAY is the initial delay in
     ms between the time when a key is pressed, and keyboard repeat
     begins.  INTERVAL is the time in ms between keyboard repeat events.
     If DELAY is 0, keyboard repeat is disabled.  Return ‘#t’ on
     success.

 -- Procedure: get-key-state
     Return a list of pressed keys (*note keysym enums::).

 -- Procedure: get-mod-state
     Return the current key modifier state as a list of symbols.

 -- Procedure: set-mod-state modstate
     Set the current key modifier state to MODSTATE, a list of symbols.
     This does not change the keyboard state, only the key modifier
     flags.

 -- Procedure: button? mask
     Return ‘#t’ if buttons specified in MASK are pressed, otherwise
     ‘#f’.  MASK is a symbol or a list of symbols from the set returned
     by ‘get-mouse-state’.

     For backward compatibility, MASK can also be the (integer) logior
     of the buttons, using mapping:

           1  left
           2  middle
           4  right
           8  wheel-up
          16  wheel-down
          32  x1
          64  x2

     For example, a value of 5 specifies both left and right buttons,
     equivalent to ‘(left right)’.

 -- Procedure: mouse-bxy [relative]
     Return three values: a (possibly empty) list of symbols
     representing pressed mouse buttons (like ‘event:button:button’),
     and two integer coordinates X and Y.

     Optional arg ‘relative’ non-‘#f’ means the coordinates are relative
     to the last time the underlying ‘SDL_GetRelativeMouseState’ was
     called.

5 Joystick
**********

 -- Procedure: num-joysticks
     Return the number of joysticks.

 -- Procedure: joystick? obj
     Return ‘#t’ iff OBJ is a joystick object.

 -- Procedure: joystick-name [n]
     Return the (string) name of the default joystick, or ‘#f’.
     Optional arg N specifies which joystick to check.

 -- Procedure: joystick-open [n]
     Return a handle to the default joystick opened for use.  Optional
     arg N specifies which joystick to open.

 -- Procedure: joystick-opened? [n]
     Return ‘#t’ iff the default joystick is opened.  Optional arg N
     specifies which joystick to check.

 -- Procedure: joystick-index joystick
     Return the index of JOYSTICK.

 -- Procedure: joystick-num-axes joystick
     Return the number of axes for JOYSTICK.

 -- Procedure: joystick-num-balls joystick
     Return the number trackballs for JOYSTICK.

 -- Procedure: joystick-num-hats joystick
     Return the number of hats for JOYSTICK.

 -- Procedure: joystick-num-buttons joystick
     Return number of buttons for JOYSTICK.

 -- Procedure: joystick-update
     Update the state of all Joysticks.

 -- Procedure: joystick-polling [setting]
     Return ‘#t’ if joystick events are polled and queued (such that it
     is unnecessary to “manually” call ‘joystick-update’), otherwise
     ‘#f’.  If SETTING is specified, set joystick events polling to the
     truth value of SETTING first.

 -- Procedure: joystick-get-axis joystick axis
     For JOYSTICK, return state of AXIS.

 -- Procedure: joystick-ball-xy joystick n
     Return relative motion of JOYSTICK trackball N as two values: ‘dx’
     and ‘dy’ (both integers).

 -- Procedure: joystick-get-hat joystick n
     For JOYSTICK, return state of hat N.

 -- Procedure: joystick-get-button joystick n
     For JOYSTICK, return state of button N, a symbol, one of:
     ‘released’ or ‘pressed’.

 -- Procedure: joystick-close joystick
     Close a previously opened JOYSTICK.

6 CDROM
*******

 -- Procedure: cd? obj
     Return ‘#t’ iff OBJ is a CDROM drive object.

 -- Procedure: cd-num-drives
     Return the number of CDROM drives.

 -- Procedure: cd-name [drive]
     Return a human-readable, system-dependent identifier (a string) for
     the CDROM, or ‘#f’.  Optional arg DRIVE is a number specifying
     which drive.

 -- Procedure: cd-open [drive]
     Open the CDROM drive for access and return its handle.  If the
     drive is unavailable, return ‘#f’.  Optional arg DRIVE is a number
     specifying which drive.

 -- Procedure: cd-status cdrom
     Return the current status of the drive CDROM as a symbol (*note
     cdrom-state enums::).

 -- Procedure: cd-in-drive? cdrom
     Return ‘#t’ iff there is a CD in drive CDROM.

 -- Procedure: cd-get-num-tracks cdrom
     Return the number of tracks on the CD in drive CDROM.

 -- Procedure: cd-get-cur-track cdrom
     Return the current track on the CD in drive CDROM.

 -- Procedure: cd-get-cur-frame cdrom
     Return the current frame of the CD in drive CDROM.

 -- Procedure: cd-nth-track-itlo cdrom [n]
     For CD in drive CDROM, return four values describing track N (zero
     if unspecified): ‘id’, ‘type’, ‘length’ and ‘offset’, all integers
     except for ‘type’, which is a symbol, either ‘audio’ or ‘data’.

 -- Procedure: cd-play-tracks cdrom [start-track [start-frame [n-tracks
          [n-frames]]]]
     Play the given CD tracks in drive CDROM.  Play the CD starting at
     START-TRACK and START-FRAME for NTRACKS tracks and NFRAMES frames.
     If both NTRACK and NFRAME are 0, play until the end of the CD. This
     procedure will skip data tracks, and should only be called after
     calling ‘cd-status’ to get track information about the CD. Return
     ‘#t’ if successful.

 -- Procedure: cd-play cdrom start length
     Play CD in drive CDROM from START frame for LENGTH frames.  Return
     ‘#t’ if successful.

 -- Procedure: cd-pause cdrom
     Pause the CD in drive CDROM.  Return ‘#t’ if successful.

 -- Procedure: cd-resume cdrom
     Resume (unpause) the CD in drive CDROM.  Return ‘#t’ if successful.

 -- Procedure: cd-stop cdrom
     Stop the CD in drive CDROM.  Return ‘#t’ if successful.

 -- Procedure: cd-eject cdrom
     Eject the CD from drive CDROM.  Return ‘#t’ if successful.

 -- Procedure: cd-close cdrom
     Close the drive CDROM.

 -- Procedure: cd-msf->frames m [s [f]]
     Return frames (an integer) computed fr M, second S and frame F.  S
     and F are optional.

 -- Procedure: frames-msf frames
     Break down FRAMES (an integer) and return three values: ‘minute’,
     ‘second’ and ‘frames’ (all integers).

7 OpenGL
********

[todo]

8 TrueType
**********

 -- Procedure: ttf-init
     Initialize the SDL_ttf subsystem.

 -- Procedure: load-font file ptsize
     Load a font from FILE with point size PTSIZE.  Return a handle.

 -- Procedure: font:style font
     Return the style of FONT (*note font-style flags::).  This font
     style is implemented by modifying the font glyphs, and doesn’t
     reflect any inherent properties of the truetype font file.

 -- Procedure: font:set-style! font style
     Set FONT style to STYLE (*note font-style flags::).  This font
     style is implemented by modifying the font glyphs, and doesn’t
     reflect any inherent properties of the truetype font file.

 -- Procedure: font:height font
     Return the total height of FONT, usually equal to point size.

 -- Procedure: font:ascent font
     Return the offset from the baseline to the top of FONT.  This is a
     positive number.

 -- Procedure: font:descent font
     Return the offset from the baseline to the bottom of FONT.  This is
     a negative number.

 -- Procedure: font:line-skip font
     Return the recommended spacing between lines of text for FONT.

 -- Procedure: font:glyph-xXyYa font ch
     Return the metrics (dimensions) of a glyph as five values.  The
     glyph is a FONT-specific rendering of char CH.  Values are: ‘minx’,
     ‘maxx’, ‘miny’, ‘maxy’ and ‘advance’ (all integers).

 -- Procedure: text-wh font text
     Return two values: ‘width’ and ‘height’ (both integers)
     representing the dimensions of the FONT-specific rendering of the
     string TEXT.

 -- Procedure: utf8-wh font text
     Return two values: ‘width’ and ‘height’ (both integers)
     representing the dimensions of the FONT-specific rendering of the
     UTF-8 string TEXT.

 -- Procedure: render-text font text fg [bg]
     Return a new surface containing the FONT-specific rendering of the
     TEXT string.  Third argument is the foreground color; optional
     fourth argument is the background color, or ‘#t’ if the text is to
     be blended.

 -- Procedure: render-utf8 font text fg [bg]
     Return a new surface containing a FONT-specific rendering of the
     utf8 string TEXT.  Third argument is the foreground color; optional
     fourth argument is the background color, or ‘#t’ if the text is to
     be blended.

 -- Procedure: render-glyph font ch fg [bg]
     Return a new surface containing a FONT-specific rendering of the
     character CH.  Third argument is the foreground color; optional
     fourth argument is the background color, or ‘#t’ if the text is to
     be blended.

 -- Procedure: ttf-quit
     Quit the SDL_ttf subsystem.

9 Audio
*******

 -- Procedure: open-audio [freq [format [stereo [chunksize]]]]
     Open the mixer with a certain audio format.  Optional args FREQ
     (number), FORMAT (number), STEREO (boolean) and CHUNKSIZE (number)
     specify those aspects of the device.  Return ‘#t’ if successful.

 -- Procedure: allocated-channels numchans
     Dynamically change the number of channels managed by the mixer to
     NUMCHANS.  If decreasing the number of channels, the upper channels
     are stopped.  Return the new number of allocated channels.

 -- Procedure: device-ffc
     Return audio device parameters as three values: ‘frequency’ (Hz),
     ‘format’ (number of bits) and ‘channels’ (number of allocated
     channels).

 -- Procedure: load-music filename
     Load music data (.mod .s3m .it .xm) from FILENAME.  Return a new
     music object if successful, otherwise ‘#f’.

 -- Procedure: load-wave filename
     Load wave data from FILENAME.  Return a new audio object if
     succesful, otherwise ‘#f’.

 -- Procedure: reserve-channels num
     Reserve the first NUM channels (0 through NUM-1) for the
     application.  In other words don’t allocate them dynamically to the
     next sample if requested with a -1 value below.  Return the number
     of reserved channels.

 -- Procedure: group-channel channel [tag]
     Attach to CHANNEL a TAG.  A tag can be assigned to several mixer
     channels, to form groups of channels.  If TAG is not specified, or
     is -1, the tag is removed (actually -1 is the tag used to represent
     the group of all the channels).  Return ‘#t’ if successful.

 -- Procedure: group-channels from to [tag]
     Assign channels in the range FROM through TO to the default group.
     Optional arg TAG specifies the group to use.  Return ‘#t’ if
     successful.

 -- Procedure: group-available [tag]
     Return the first available channel in the default group of
     channels.  Optional arg TAG specifies the group to check.

 -- Procedure: group-count [tag]
     Return the number of channels in the default group.  Optional arg
     TAG specifies the group to check.

 -- Procedure: group-oldest [tag]
     Return the "oldest" sample playing in the default group of
     channels.  Optional arg TAG specifies the group to check.

 -- Procedure: group-newer [tag]
     Return the "most recent" (i.e.  last) sample playing in the default
     group of channels.  Optional arg TAG specifies the group to check.

 -- Procedure: play-channel chunk [channel [loops [ticks [fade]]]]
     Play an audio CHUNK on a specific CHANNEL.  If the channel is
     unspecified or is -1, play on the first free channel.  If LOOPS is
     specified and greater than zero, loop the sound that many times.
     If LOOPS is -1, loop infinitely (~65000 times).  If TICKS is
     specified, stop after that number of ticks.  If FADE is specified,
     fade in over that number of milliseconds.  Return which channel was
     used to play the sound.

 -- Procedure: play-music music [loops [fade]]
     Play a MUSIC track.  Optional args LOOPS and FADE are as in
     ‘play-channel’.

 -- Procedure: volume [volume [which]]
     Return the current volume on the default channel.  Optional arg
     VOLUME (a number in the range 0-128) means set the volume to VOLUME
     and return the original volume.  Optional second arg WHICH
     specifies a chunk or channel to check (or modify) instead of the
     default.  If VOLUME is non-‘#f’ and WHICH is ‘#f’, modify all
     channels.

     [Here is the original (perhaps clearer) docstring.  —ttn]

     Set the volume in the range of 0-128 of a specific channel or
     chunk.  If the channel is unspecified or is -1, set volume for all
     channels.  Return the original volume.  If the volume is
     unspecified or is -1, just return the current volume.

 -- Procedure: music-volume [volume]
     Return the current volume.  Optional arg VOLUME (a number in the
     range 0-128) means set the volume to VOLUME.

 -- Procedure: halt-channel [channel]
     Halt playing of the default channel.  Optional arg CHANNEL
     specifies a channel to halt.

 -- Procedure: halt-group [tag]
     Halt playing of the default group.  Optional arg TAG specifies the
     group to halt.

 -- Procedure: halt-music
     Halt playing of the music.

 -- Procedure: expire-channel [channel [ticks]]
     Turn off expiration for the default channel.  Optional arg CHANNEL
     specifies a channel to change.  Optional arg TICKS (a number) means
     set the expiration delay to that many milliseconds, rather than
     turning it off.

 -- Procedure: fade-out-channel [which [ms]]
     Halt a channel, fading it out progressively until silent.  Optional
     arg WHICH specifies a channel to halt.  Second optional arg MS
     specifies the number of milliseconds the fading will take (default
     0).

 -- Procedure: fade-out-group [tag [ms]]
     Halt a group, fading it out progressively until silent.  Optional
     arg TAG specifies a group to halt.  Second optional arg MS
     specifies the number of milliseconds the fading will take (default
     0).

 -- Procedure: fade-out-music [ms]
     Halt the music, fading it out progressively until silent.  Optional
     arg MS specifies the number of milliseconds the fading will take
     (default 0).

 -- Procedure: fading-music
     Return the fading status of the music, one of the symbols: ‘no’,
     ‘out’, ‘in’.

 -- Procedure: fading-channel [which]
     Return the fading status (a symbol, see ‘fading-music’) of the
     default channel.  Optional arg WHICH selects which channel to
     check.

 -- Procedure: pause [channel]
     Pause the default channel.  Optional arg CHANNEL selects which
     channel to pause.

 -- Procedure: resume [channel]
     Resume (unpause) the default channel.  Optional arg CHANNEL selects
     which channel to resume.

 -- Procedure: paused? [channel]
     Return ‘#t’ if the default channel is paused.  Optional arg CHANNEL
     selects a which channel to check.

 -- Procedure: pause-music
     Pause the music.

 -- Procedure: resume-music
     Resume (unpause) the music.

 -- Procedure: rewind-music
     Rewind the music.

 -- Procedure: paused-music?
     Return ‘#t’ if the music is currently paused.

 -- Procedure: playing? [channel]
     Return ‘#t’ iff the default channel is playing.  Optional arg
     CHANNEL selects which channel to check.

 -- Procedure: playing-music?
     Return ‘#t’ iff the music is currently playing.

 -- Procedure: set-music-command command
     Stop music and set external music playback command to COMMAND, a
     string.  As a special case, if COMMAND is ‘#f’, arrange to use
     internal playback, instead.

FWIW, the C header file for the following panning, distance and position
procs says:

     Setting (channel) to MIX_CHANNEL_POST registers this as a
     posteffect, and the panning will be done to the final mixed stream
     before passing it on to the audio device.

 -- Procedure: set-panning channel l r
     Set panning for (stereo) CHANNEL with L and R.  Both L and R are
     integers 0–255, inclusive, where 0 is quietest and 255 is loudest.

     To get “true” panning, use ‘(set-panning CH N (- 255 N))’.

 -- Procedure: set-distance channel distance
     Set the “distance” of CHANNEL to DISTANCE (integer, 0–255).  This
     controls the location of the sound with respect to the listener.

     Distance 0 is overlapping the listener, and 255 is as far away as
     possible.  A distance of 255 does not guarantee silence; in such a
     case, you might want to try changing the chunk’s volume, or just
     cull the sample from the mixing process with ‘halt-channel’.

     For efficiency, the precision of this effect may be limited
     (distances 1 through 7 might all produce the same effect, 8 through
     15 are equal, etc).

     Setting (distance) to 0 unregisters this effect, since the data
     would be unchanged.

 -- Procedure: set-position channel angle distance
     Set the “position” of CHANNEL to ANGLE, DISTANCE.  In this polar
     coordinate, ANGLE is in degrees (integer modulo 360), and DISTANCE
     is an integer 0–255 (and is treated as in proc ‘set-distance’ – see
     notes there).

     Angle 0 is due north, and rotates clockwise as the value increases.
     For efficiency, the precision of this effect may be limited (angles
     1 through 7 might all produce the same effect, 8 through 15 are
     equal, etc).

     Setting ANGLE and DISTANCE to 0 unregisters this effect, since the
     data would be unchanged.

     Additionally, the C header says:
          If the audio device is configured for mono output, then you
          won’t get any effectiveness from the angle; however, distance
          attenuation on the channel will still occur.  While this
          effect will function with stereo voices, it makes more sense
          to use voices with only one channel of sound, so when they are
          mixed through this effect, the positioning will sound correct.
          You can convert them to mono through SDL before giving them to
          the mixer in the first place if you like.

 -- Procedure: close-audio
     Close the mixer, halting all playing audio.

10 SDL_gfx by Andreas Schiffler
*******************************

10.1 Graphics Primitives
========================

 -- Procedure: draw-point surface x y color
     On SURFACE, draw a point at location X,Y with color COLOR.

 -- Procedure: draw-hline surface x1 x2 y color
     On SURFACE, draw a horizontal line segment from X1,Y to X2,Y, with
     color COLOR.

 -- Procedure: draw-vline surface x y1 y2 color
     On SURFACE, draw a vertical line segment from X,Y1 to X,Y2, with
     color COLOR.

 -- Procedure: draw-rectangle surface x1 y1 x2 y2 color [fill]
     On SURFACE, draw a rectangle with opposite points X1,Y1 and X2,Y2,
     with color COLOR.  Optional arg FILL means to fill the rectangle as
     well.

 -- Procedure: draw-rounded-rectangle surface x1 y1 x2 y2 rad color
          [fill]
     On SURFACE, draw a rectangle with opposite points X1,Y1 and X2,Y2,
     with rounded corners radius RAD in color COLOR.  Optional arg FILL
     means to fill the rectangle as well.

 -- Procedure: draw-line surface x1 y1 x2 y2 color
     On SURFACE, draw a line segment from X1,Y1 to X2,Y2, with color
     COLOR.

 -- Procedure: draw-aa-line surface x1 y1 x2 y2 color
     On SURFACE, draw an anti-aliased line segment from X1,Y1 to X2,Y2,
     with color COLOR.

 -- Procedure: draw-thick-line surface x1 y1 x2 y2 width color
     On SURFACE, draw a line segment from X1,Y1 to X2,Y2, with thickness
     WIDTH in color COLOR.

 -- Procedure: draw-arc surface x y r start end color
     On SURFACE, draw arc with center X,Y and radius R, going from START
     to END (degrees), with color COLOR.

     If START is greater than END, the effective range of the arc is
     taken to be END to START (that is, these arguments are internally
     reversed).

 -- Procedure: draw-circle surface x y r color [fill]
     On SURFACE, draw a circle with center X,Y and radius R, with color
     COLOR.  Optional arg FILL means to fill the circle as well.

 -- Procedure: draw-aa-circle surface x y r color
     On SURFACE, draw an anti-aliased circle with center X,Y and radius
     R, with color COLOR.

 -- Procedure: draw-ellipse surface x y rx ry color [fill]
     On SURFACE, draw an ellipse with center X,Y x-radius RX, y-radius
     RY, with color COLOR.  Optional arg FILL means to fill the ellipse
     as well.

 -- Procedure: draw-aa-ellipse surface x y rx ry color
     On SURFACE, draw an anti-aliased ellipse with center X,Y, x-radius
     RX, y-radius RY, with color COLOR.

 -- Procedure: draw-pie-slice surface x y rad start end color [fill]
     On SURFACE, draw a pie slice with center X,Y and radius RAD, going
     from START to END (degrees), with color COLOR.  Optional arg FILL
     means to fill the slice as well.

 -- Procedure: draw-trigon surface x1 y1 x2 y2 x3 y3 color [fill]
     On SURFACE, draw a triangle with vertices at X1,Y1, X2,Y2 and
     X3,Y3, with color COLOR.  Optional arg FILL means to fill the
     triangle as well.

 -- Procedure: draw-aa-trigon surface x1 y1 x2 y2 x3 y3 color
     On SURFACE, draw an anti-aliased triangle with vertices at X1,Y1,
     X2,Y2 and X3,Y3, with color COLOR.

 -- Procedure: draw-polygon surface vx vy color [fill]
     On SURFACE, draw a polygon whose points are specified by
     corresponding pairs from the s16 uniform vectors VX and VY, in
     color COLOR.  Optional arg FILL means to fill the polygon as well.

 -- Procedure: draw-aa-polygon surface vx vy color
     On SURFACE, draw an anti-aliased polygon whose points are specified
     by corresponding pairs from the s16 uniform vectors VX and VY, in
     color COLOR.

 -- Procedure: draw-textured-polygon surface vx vy texture tdx tdy
     On SURFACE, draw a polygon whose points are specified by
     corresponding pairs from the s16 uniform vectors VX and VY, filling
     from TEXTURE (a surface) with offset TDX, TDY.

 -- Procedure: draw-bezier surface vx vy s color
     On SURFACE, draw a bezier curve whose points are specified by
     corresponding pairs from the s16 uniform vectors VX and VY, with S
     steps in color COLOR.

 -- Procedure: draw-character surface x y c color
     On SURFACE at position X,Y, draw char C with COLOR (a number).

 -- Procedure: draw-string surface x y text color
     On SURFACE at position X,Y, draw string TEXT with COLOR (a number).

 -- Procedure: font-rotation! rotation
     Set the rotation for glyphs drawn by ‘draw-character’ and
     ‘draw-string’ to ROTATION (an integer or symbol), one of:

          0  none
          1  clockwise
          2  upside-down
          3  counter-clockwise

10.2 Rotation / Zooming
=======================

 -- Procedure: roto-zoom-surface surface angle [zoom [smooth]]
     Return a new surface made from rotating SURFACE by ANGLE degrees.
     Optional third arg ZOOM (default value 1.0) changes the size as
     well.  Optional fourth arg SMOOTH turns on anti-aliasing.

 -- Procedure: roto-zoom-surface-xy surface angle [zoomx [zoomy
          [smooth]]]
     Return a new surface made from rotating SURFACE by ANGLE degrees.
     Optional third and fourth args ZOOMX and ZOOMY (default value 1.0
     for both) changes the size as well.  Optional fifth arg SMOOTH
     turns on anti-aliasing.

 -- Procedure: zoom-surface surface zoomx [zoomy [smooth]]
     Return a new scaled copy of SURFACE.  ZOOMX and ZOOMY specify the
     scaling factor.  If omitted, ZOOMY defaults to ZOOMX.  Optional
     fourth arg SMOOTH turns on anti-aliasing.

 -- Procedure: shrink-surface surface factorx factory
     Return a new shrunken copy of SURFACE.  FACTORX and FACTORY are
     positive integers specifying the inverse scaling factor.  For
     example, 2 means half size, 3 means one-third size, etc.

     The returned surface is antialiased by “averaging the source box
     RGBA or Y information” and is in 32-bit RGBA format.

10.3 Managing Frame Rate
========================

 -- Procedure: make-fps-manager [n]
     Return a FPS manager object to be passed as the first arg to
     ‘fps-manager-set!’, ‘fps-manager-get’ and ‘fps-manager-delay!’.
     Optional arg N specifies the value in Hz to initialize the object
     (default 30 if not specified).

 -- Procedure: fps-manager-set! mgr n
     Arrange for FPS manager MGR to try to maintain a frame rate of N
     Hz.  Return ‘#f’ if not successful.

 -- Procedure: fps-manager-get mgr
     Return the frame rate of FPS manager MGR in Hz, or ‘#f’ if
     unsuccessful.

 -- Procedure: fps-manager-delay! mgr
     Request an appropriate delay from FPS manager MGR.

10.4 RGBA Extras
================

 -- Procedure: set-pixel-alpha! surface alpha
     If SURFACE is 32-bit, set each pixel’s alpha value to ALPHA, an
     integer 0-255, inclusive, and return ‘#t’.  Otherwise, do nothing
     and return ‘#f’.

 -- Procedure: blit-rgba src srect dst drect
     Blit from 32-bit surface SRC rectangle SRECT to 32-bit surface DST
     rectangle DRECT.  Return ‘#t’ if there are no problems.

     Note that unlike ‘blit-surface’ (*note Video::), all arguments must
     be fully specified.  This restriction may be relaxed in the future.

10.5 Image Filtering
====================

 -- Procedure: imfi-mmx? [setting]
     If SETTING is ‘#t’, enable MMX instructions for the image filter
     procs (if possible); if ‘#f’, disable; otherwise do nothing.
     Return the (boolean) value of the setting afterwards.

 -- Procedure: imfi-add src1 src2 dst
     D = saturation255 (S1 + S2).

 -- Procedure: imfi-mean src1 src2 dst
     D = S1/2 + S2/2.

 -- Procedure: imfi-sub src1 src2 dst
     D = saturation0 (S1 - S2).

 -- Procedure: imfi-abs-diff src1 src2 dst
     D = | S1 - S2 |.

 -- Procedure: imfi-mult src1 src2 dst
     D = saturation (S1 * S2).

 -- Procedure: imfi-mulnor src1 src2 dst
     D = S1 * S2 (non-MMX).

 -- Procedure: imfi-muldiv2 src1 src2 dst
     D = saturation255 (S1/2 * S2).

 -- Procedure: imfi-muldiv4 src1 src2 dst
     D = saturation255 (S1/2 * S2/2).

 -- Procedure: imfi-logand src1 src2 dst
     D = S1 & S2.

 -- Procedure: imfi-logior src1 src2 dst
     D = S1 | S2.

 -- Procedure: imfi-div src1 src2 dst
     D = S1 / S2 (non-MMX).

 -- Procedure: imfi-not src dst
     D = !S.

 -- Procedure: imfi-add-c src dst c
     D = saturation255 (S + C).

 -- Procedure: imfi-add-c-to-half src dst c
     D = saturation255 (S/2 + C).

 -- Procedure: imfi-sub-c src dst c
     D = saturation0 (S - C).

 -- Procedure: imfi-ashr src dst n
     D = saturation0 (S >> N).

 -- Procedure: imfi-lshr src dst n
     D = saturation0 ((uint) S >> N).

 -- Procedure: imfi-mul-c src dst c
     D = saturation255 (S * C).

 -- Procedure: imfi-ashr-mul-c src dst n c
     D = saturation255 ((S >> N) * C).

 -- Procedure: imfi-bshl src dst n
     D = (S << N).

 -- Procedure: imfi-lshl src dst n
     D = ((uint) S << N).

 -- Procedure: imfi-ashl src dst n
     D = saturation255 (S << N).

 -- Procedure: imfi-binarize src dst t
     D = (S < T ?  0 : 255).

 -- Procedure: imfi-clip src dst tmin tmax
     D = (Tmin <= S <= Tmax) ?  255 : 0.

 -- Procedure: imfi-normalize-linear src dst cmin cmax nmin nmax
     D = saturation255 ((Nmax - Nmin) / (Cmax - Cmin) * (S - Cmin) +
     Nmin).

11 Miscellaneous Utilities
**************************

These are available in module ‘(sdl misc-utils)’.

 -- Procedure: exact-truncate number
     Return the exact truncation (rounding to zero) of NUMBER.  This is
     “safer” than simply ‘inexact->exact’ for some Guile versions.

          (define scale 0.180281690140845)
          (inexact->exact scale)
            ⇒ 3247666210160131/18014398509481984 ; Guile 1.8.7
            ⇒ 0                                  ; Guile 1.4.x
          (exact-truncate scale)
            ⇒ 0

 -- Procedure: call-with-clip-rect rect thunk
     Set default clip rect to RECT, call THUNK, and restore it.  THUNK
     is a procedure that takes no arguments.

 -- Procedure: rotate-square square angle
     Return a new surface made by rotating SQUARE by ANGLE degrees.  The
     square retains its original size.

 -- Procedure: rectangle-closure [rect]
     Return a closure that manages a single rectangle object.  Calling
     the closure with no args returns the rectangle object.  Otherwise,
     the messages ‘#:w’, ‘#:h’, ‘#:x’ and ‘#:y’ return the rectangle’s
     width, height, horizontal offset and vertical offset, respectively;
     and the messages ‘#:w!’, ‘#:h!’, ‘#:x!’ and ‘#:y!’, followed by an
     integer, update the rectangle’s width, height, horizontal offset
     and vertical offset, respectively.

     Optional arg RECT specifies a rectangle object to manage instead of
     allocating a new one.

 -- Procedure: rectangle<-geometry-string spec
     Return a rectangle made from parsing the "geometry string" SPEC,
     which typically has the form ‘WxH+X+Y’, where ‘+X+Y’ is optional
     (defaults to “+0+0”), and ‘W’, ‘H’, ‘X’ and ‘Y’ are integers.
     Actually, the ‘+’ can also be a ‘-’.  If SPEC cannot be parsed,
     return ‘#f’.  Examples:

          (rectangle<-geometry-string "42x43+44+45")
          ⇒ #<SDL-Rect 42x43+44+45>

          (rectangle<-geometry-string "42x43-10-20")
          ⇒ #<SDL-Rect 42x43+-10+-20>

          (rectangle<-geometry-string "42x43")
          ⇒ #<SDL-Rect 42x43+0+0>

          (rectangle<-geometry-string "42")
          ⇒ #f

     Note that the print representation of a rectangle always has “+”.
     The term “geometry string” derives from the X Window System, where
     many programs take a ‘--geometry’ (or ‘-g’ for short) command-line
     option.

 -- Procedure: poll-with-push-on-timeout-proc timeout slice
          [get-timeout-events]
     Return a procedure ‘P’ that checks the event queue for TIMEOUT ms,
     polling every SLICE ms.  If an event arrives during that time,
     return ‘#t’.  Otherwise return ‘#f’.  Optional arg
     GET-TIMEOUT-EVENTS is either a list of events to be pushed on the
     queue in the case of timeout, or a thunk to be called that produces
     such a list.  If GET-TIMEOUT-EVENTS is specified, return the result
     of another event queue polling.  (This may still be ‘#f’ if the
     pushed events are masked in some way.)

     ‘P’ is called with a single arg, a pre-constructed event object.
     This interface is congruent with that of ‘wait-event’ and
     ‘poll-event’.  *Note Events::.

 -- Procedure: rect<-surface surface [x y]
     Return a new rectangle with the same width and height as SURFACE.
     Optional second and third arg (which must appear together or not at
     all) specifies the X and Y components, respectively, to use instead
     of the default of 0 (zero).

 -- Procedure: copy-rectangle rect [modify args...]
     Return a new rectangle copied from RECT.

     Optional second arg MODIFY specifies which portions, if any, to
     modify using the values in the rest ARGS.  If MODIFY is ‘#:xy’, the
     two ARGS specify new ‘x’ and ‘y’ values.  If MODIFY is ‘#:wh’, the
     two ARGS specify new ‘w’ and ‘h’ values.

          rect
          ⇒ #<SDL-Rect 3x4+1+2>

          (copy-rectangle rect)
          ⇒ #<SDL-Rect 3x4+1+2>

          (copy-rectangle rect #:xy 11 22)
          ⇒ #<SDL-Rect 3x4+11+22>

          (copy-rectangle rect #:wh 33 44)
          ⇒ #<SDL-Rect 33x44+1+2>

 -- Procedure: copy-surface surface [clip]
     Create a new surface and blit SURFACE onto it.  The new surface has
     the same pixel format as SURFACE.  Return the new surface.

     Optional second arg CLIP is a rectangle describing the portion of
     SURFACE to copy (default is the entire surface).

 -- Procedure: ignore-all-event-types-except [types…]
     Arrange to ignore all event types except those in TYPES (*note
     event-type enums::).  As a special case, if TYPES is ‘#f’, arrange
     to not ignore any event types (all are enabled).

In the following procs, those named ending with ‘/3p’ return three
values, each a thunk (unless specified otherwise) handling the
three-phase calling convention, namely "init", "next", and "done".

     (call-with-values (lambda () (foo/3p ...))
       (lambda (init! foo! done!)
         (init!)
         (let loop ((continue? (foo!)))
           (and continue? (loop (foo!))))
         (done!)))

Note that ‘foo!’ returns non-‘#f’ to indicate that the looping is not
yet complete.

 -- Procedure: fader/3p sec realized location image replacement
     Return three values, each a thunk, that can be used to loop for SEC
     seconds, blitting onto REALIZED at LOCATION (a rectangle or ‘#f’ to
     indicate the origin) the alpha-composition of IMAGE and its
     REPLACEMENT (both surfaces), to effect a "fade-in" of REPLACEMENT
     over IMAGE.  The alpha value is directly proportional to the time
     between the “next!” phase call and the “init!” phase call.

     REALIZED may be either a surface, in which case at the end of each
     loop it is shown via ‘update-rect’; or a pair whose CAR is a
     surface and whose CDR is a thunk that should do the showing.

     Note that LOCATION is used for blitting, so its width and height
     should match those of IMAGE and REPLACEMENT.

 -- Procedure: toroidal-panner/3p surface dx dy [sub [batch?]]
     Return three values, the first a procedure of one arg, the other
     two thunks, that can be used to toroidally pan SURFACE by DX and DY
     pixels.  This means that data disappearing from one side of the
     surface (left, right, top, bottom) is rotated to appear at the
     other side (right, left, bottom, top).  The ‘init!’ procedure takes
     one arg COUNT, the number of pans to do.

     Positive DX moves surface data to the left (panning right), and
     likewise, positive DY, up (panning down).

     Optional third arg SUB is a rectangle object specifying a subset of
     the surface.  The default is to pan the entire surface.

     Optional fourth arg BATCH? non-‘#f’ means to call ‘update-rect’ on
     the (sub)surface after all the panning is done.  The default is to
     update the surface after each pan.  Batch mode is useful for
     implementing variable-speed panning, for example:

          (define (pan dir)
            (call-with-values (lambda ()
                                (toroidal-panner/3p screen
                                                    (* dir 21)
                                                    (* dir 12)
                                                    #f #t))
              (lambda (init! next! done!)
                (lambda (count)
                  (init! count)
                  (let loop ((continue? (next!)))
                    (and continue? (loop (next!))))
                  (done!)))))

          (define pan-away (pan  1))
          (define pan-back (pan -1))
          (define ramp (map 1+ (append (make-list 21 0)
                                       (identity (iota 12))
                                       (reverse! (iota 12))
                                       (make-list 21 0))))
          (for-each pan-away ramp)
          (for-each pan-back ramp)

12 Simple Closures
******************

This chapter documents module ‘(sdl simple)’.

This module provides some simple abstractions to introduce common
Guile-SDL programming idioms.  Although the interfaces are documented,
they are "permanently alpha", that is, subject to change w/o notice.
Instead of relying on the stability of the interface, you are encouraged
to look at the implementation as a model for creating customized
abstractions.

 -- Procedure: simple-canvas init? w h bpp [flags…]
     Return a "canvas closure" that accepts a few simple messages.  If
     INIT? is non-‘#f’, initalize the SDL video subsystem first.  W, H,
     and BPP specify the width, height, and bits-per-pixel,
     respectively.  FLAGS are symbols to set the video mode.  If
     omitted, the default is ‘hw-surface’ and ‘doublebuf’.

     The closure, if called without arguments, returns the video
     surface.  Otherwise, the following messages are recognized:

     ‘#:rect’
          Return a rectangle the width and height of the canvas.

     ‘#:set-bg! r g b’
          Set the background color (used for clearing) to the color
          specified by R, G and B (integers 0-255), respectively.  By
          default it is black (all values zero).

     ‘#:clear!’
          Fill the canvas with the background color.

     ‘#:w’
     ‘#:h’
     ‘#:w/h’
          Return width, height, or a cons of width and height,
          respectively.

     ‘#:resize! new-width new-height’
          Request that the canvas dimension be changed to NEW-WIDTH by
          NEW-HEIGHT.  Return a rect that reflects the actual dimension.

 -- Procedure: simple-stylus init? filename size r g b
     Return a "stylus closure" that accepts a few simple messages.  If
     INIT? is non-‘#f’, initialize the SDL TTF support first.  FILENAME
     specifes the .ttf file to load and ‘size’ the size.  R, G and B are
     integers (0-255) specifying the color.  The closure recognizes the
     following messages:

     ‘#:set-font! filename size’
     ‘#:set-color! r g b’
          Change the font or color, respectively.

     ‘#:set-canvas! surface’
          Set the surface on which the ‘#:write!’ command renders.

     ‘#:render text [color [bg]]’
          Return a surface of TEXT rendered using the default font,
          size, color and size.  Optional second arg COLOR specifies
          another color to use.  Optional third arg BG specifies a
          background mode: ‘#f’ (default) for “solid”; ‘#t’ for
          “blended”; a color to use that color.

     ‘#:write! where text [color [bg]]’
          Similar to #:render, but also blit the surface onto the canvas
          at the rectangle position specified by WHERE.  The width and
          height components of WHERE are updated by side effect.

 -- Procedure: simple-vpacked-image filename [canvas]
     Return a "vpacked image closure" that accepts a few simple
     messages.  "Vpacked" means multiple vertically-abutted images of
     dimensions NxN (at the top) through Nx1 (at the bottom), stored in
     a single image file.  FILENAME specifies the file and optional arg
     CANVAS specifies a surface for blitting.  The closure recognizes
     the following messages:

     ‘#:set-canvas! surface’
          Change the canvas.

     ‘#:rects’
          Return the vector of rectangles of length N+1 (the element at
          index zero is ‘#f’) corresponding to areas on the image
          representing the smaller sub-images.  The element at index I
          is a rectangle of dimension IxI.

     ‘#:blit! i rect’
          Blit the sub-image I (an integer 1 <= I <= N), onto the
          canvas.  RECT specifies a rectangle to blit to.

13 Excuses
**********

Here are some notes on interface elements from ‘/usr/include/SDL/*.h’
that are not yet wrapped by Guile-SDL. As things progress elements will
be removed until an irreducible set remains.

Interface elements have zero or more "attributes", some of which
indicate irreducibility (such as ‘probably-never’).  Following the
attribute groupings are specific notes on those elements that are
particular in some way.  The presentation order is not significant.

13.1 Categories
===============

For brevity, we omit the ‘SDL_’ prefix in the groupings.  There are two
speical cases: ‘(N)’ stands for ‘SDLNet_’, and ‘(M)’ stands for ‘Mix_’.

‘internal’

     These interface elements are exposed in the C header but should not
     be exposed to Scheme, for reasons of either safety or inutility.

       SoftStretch  LowerBlit  UpperBlit
       VideoInit  VideoQuit  AudioQuit  AudioInit
       (M)GetChunk

‘probably-never’

     Don’t expect to see these exposed to Scheme, ever!

       SoftStretch  SaveBMP_RW  LoadBMP_RW
       VideoInit  VideoQuit  InitQuickDraw  RegisterApp
       SetModuleHandle  getenv  putenv
       ClearError  SetError  WriteBE64  WriteLE64
       WriteBE32  WriteLE32  WriteBE16  WriteLE16
       ReadBE64  ReadLE64  ReadBE32  ReadLE32
       ReadBE16  ReadLE16  CloseAudio  UnlockAudio
       LockAudio  MixAudio  ConvertAudio  BuildAudioCVT
       FreeWAV  LoadWAV_RW  PauseAudio  GetAudioStatus
       OpenAudio  AudioDriverName  AudioQuit
       AudioInit  (M)GetMusicHookData  (M)GetChunk

‘doze’

     Windoze support, blech.

       SaveBMP_RW  LoadBMP_RW  RegisterApp
       SetModuleHandle

‘threading-implications’

     Will (any :–) ttn ever be ready for parallelism?

       RemoveTimer  AddTimer  SetTimer  KillThread
       WaitThread  GetThreadID  ThreadID
       CreateThread  CondWaitTimeout  CondWait
       CondBroadcast  CondSignal  DestroyCond
       CreateCond  SemValue  SemPost  SemWaitTimeout
       SemTryWait  SemWait  DestroySemaphore  CreateSemaphore
       DestroyMutex  mutexV  mutexP  CreateMutex

‘todo’

     To be completed by Guile-SDL 1.0 (that is, if All Goes Well).

       KillThread  WaitThread  GetThreadID
       ThreadID  CreateThread  CondWaitTimeout
       CondWait  CondBroadcast  CondSignal
       DestroyCond  CreateCond  SemValue
       SemPost  SemWaitTimeout  SemTryWait
       SemWait  DestroySemaphore  CreateSemaphore
       DestroyMutex  mutexV  mutexP  CreateMutex
       (N)Init  (N)Quit  (N)ResolveHost  (N)ResolveIP
       (N)TCP_Open  (N)TCP_Accept  (N)TCP_GetPeerAddress
       (N)TCP_Send  (N)TCP_Recv  (N)TCP_Close
       (N)AllocPacket  (N)ResizePacket  (N)FreePacket
       (N)AllocPacketV  (N)FreePacketV  (N)UDP_Open
       (N)UDP_Bind  (N)UDP_Unbind  (N)UDP_GetPeerAddress
       (N)UDP_SendV  (N)UDP_Send  (N)UDP_RecvV
       (N)UDP_Recv  (N)UDP_Close  (N)AllocSocketSet
       (N)AddSocket  (N)DelSocket  (N)CheckSockets
       (N)SocketReady  (N)FreeSocketSet  (N)Write16
       (N)Write32  (N)Read16  (N)Read32  (M)SetPostMix
       (M)HookMusic  (M)HookMusicFinished  (M)ChannelFinished
       (M)RegisterEffect  (M)UnregisterEffect  (M)UnregisterAllEffects
       (M)SetReverb  (M)SetReverseStereo  (M)SetMusicPosition
       (M)SetSynchroValue  (M)GetSynchroValue

‘rwops’

     Read-write operations.

       FreeRW  AllocRW  RWFromMem  RWFromConstMem
       RWFromFile

‘macos’

     Macintosh support, meh.

       InitQuickDraw

‘endian’

     These concern little- vs.  big-endian i/o.  Perhaps Guile already
     provides decent alternatives.

       WriteBE64  WriteLE64  WriteBE32  WriteLE32
       WriteBE16  WriteLE16  ReadBE64  ReadLE64
       ReadBE32  ReadLE32  ReadBE16  ReadLE16

‘use-mixer-instead’

     These elements are obsoleted by the module ‘(sdl mixer)’.

       CloseAudio  UnlockAudio  LockAudio
       MixAudio  ConvertAudio  BuildAudioCVT
       FreeWAV  LoadWAV_RW  PauseAudio  GetAudioStatus
       OpenAudio  AudioDriverName  AudioQuit
       AudioInit

‘hook’

     Callback from SDL to Scheme code.  Can be tricky to get right...

       (M)SetPostMix  (M)HookMusic  (M)HookMusicFinished  (M)ChannelFinished
       (M)RegisterEffect  (M)UnregisterEffect  (M)UnregisterAllEffects

13.2 Specific Notes
===================

‘SDL_SoftStretch’
     SDL_video.h sez:
     /* Not in public API at the moment - do not use! */

‘SDL_CreateRGBSurfaceFrom’
     not sure what this is useful for

‘SDL_GL_UpdateRects’
     arglist: (int numrects, SDL_Rect* rects)

     we can either try to map uniform vectors (of smobs),
     or introduce a `RectVector' smob.

‘SDL_VideoInit’
     actually, SDL_video.h sez:
     /* These functions are used internally, and should not be used unless you
      * have a specific need to specify the video driver you want to use.
      * You should normally use SDL_Init() or SDL_InitSubSystem().
      * ...
      */

‘SDL_VideoQuit’
     see note for `SDL_VideoInit'

‘SDL_Linked_Version’
     SDL_version.h sez:
     /* This function gets the version of the dynamically linked SDL library.
        it should NOT be used to fill a version structure, instead you should
        use the SDL_Version() macro.
      */

‘SDL_GetWMInfo’
     return value for proc `get-wm-info' does not presently
     include the `lock_func' and `unlock_func' hooks.
     support for those will be added after i figure out
     how to "thunkify" them.

‘SDL_GetKeyName’
     why do we want to know the name of a key?

‘SDL_AudioQuit’
     SDL_audio.h sez:
     /* These functions are used internally, and should not be used unless you
      * have a specific need to specify the audio driver you want to use.
      * You should normally use SDL_Init() or SDL_InitSubSystem().
      */

‘SDL_AudioInit’
     see note for `SDL_AudioQuit'

‘SDLNet_AddSocket’
     there are also:
     #define SDLNet_TCP_AddSocket
     #define SDLNet_UDP_AddSocket

‘SDLNet_DelSocket’
     there are also:
     #define SDLNet_TCP_DelSocket
     #define SDLNet_UDP_DelSocket

‘Mix_GetMusicHookData’
     If (when) `Mix_HookMusic' is added, it will not support "user data".
     It's better to use object properties for that.

Appendix A Stashes
******************

There are 21 stashes (11 enums, 10 flags).

Distribution of symbols count:
       2     5 =========================            min: 2
       3     3 ===============                      max: 231
       4     1 =====                               mean:   17.0
       5     4 ====================              median: 5.0
       7     2 ==========
       8     1 =====
      11     1 =====
      15     1 =====
      17     1 =====
      18     1 =====
     231     1 =====

Distribution of symbol lengths:
       1    26 =============                        min: 1
       2    19 ==========                           max: 17
       3    23 ============                        mean: 6.5126
       4    38 ===================               median: 7.0
       5    28 ==============
       6    31 ================
       7    28 ==============
       8   103 ====================================================
       9    18 =========
      10    13 =======
      11     4 ==
      12    10 =====
      13     3 ==
      14     2 =
      15     8 ====
      17     3 ==

 -- 2 enums: activity-change

          lost             gained

 -- 2 enums: alpha-limit

          transparent      opaque

 -- 3 flags: application-state

          mousefocus       inputfocus       active

 -- 2 enums: cd-track-type

          audio            data

 -- 5 enums: cdrom-state

          error            stopped          paused
          tray-empty       playing

 -- 18 flags: event-mask
     Note that these are a proper superset of those in the ‘event-type’
     enums, below.

          active             mouse-button-up    joy-button-up
          key-down           mouse              joy
          key-up             joy-axis-motion    quit
          key                joy-ball-motion    sys-wm
          mouse-motion       joy-hat-motion     video-resize
          mouse-button-down  joy-button-down    video-expose

 -- 15 enums: event-type
     Note that these are a proper subset of those in the ‘event-mask’
     flags, above.

          active             mouse-button-up    joy-button-up
          key-down           joy-axis-motion    quit
          key-up             joy-ball-motion    sys-wm
          mouse-motion       joy-hat-motion     video-resize
          mouse-button-down  joy-button-down    video-expose

 -- 3 enums: fading-status

          no               out              in

 -- 4 enums: font-rotation

          none               upside-down
          clockwise          counter-clockwise

 -- 5 flags: font-style

          normal           italic           strikethrough
          bold             underline

 -- 3 enums: grab-mode

          query            off              on

 -- 8 flags: init

          timer            cdrom            no-parachute
          audio            joystick         event-thread
          video            everything

 -- 5 flags: joystick-hat-position

          centered         right            left
          up               down

 -- 11 flags: keyboard-modifier

          L-shift          L-alt            num
          R-shift          R-alt            caps
          L-ctrl           L-meta           mode
          R-ctrl           R-meta

 -- 2 enums: keyboard/button-state

          released         pressed

 -- 231 enums: keysym
     Note that digits begin with ‘D-’ so that they are unambiguously (to
     ‘read’) symbols.

          a b c d e f g h i j k l m n o p q r s t u v w x y z
          D-0 … D-9

          ampersand   backquote   capslock   delete   end
          asterisk    backslash   caret      dollar   equals
          at          backspace   clear               escape
                      break       colon               euro
                                  comma               exclaim
                                  compose

          f1 … f15

          hash   insert
          help
          home

          kp-0 … kp-9

          kp-plus         kp-equals
          kp-minus        kp-period
          kp-multiply     kp-enter
          kp-divide

          left  right  up  down

          L-alt  L-ctrl  L-meta  L-shift  L-super
          R-alt  R-ctrl  R-meta  R-shift  R-super

          L-bracket  R-bracket
          L-paren    R-paren

          less  greater

          menu      pagedown   question   scrollock   tab
          minus     pageup     quote      semicolon
          mode      pause      quotedbl   slash       underscore
          numlock   period                space       undo
                    plus       return     sysreq
                    power
                    print

          world-0 … world-95

 -- 7 flags: mouse-button

          left             wheel-up         x1
          middle           wheel-down       x2
          right

 -- 7 enums: mouse-button

          left             wheel-up         x1
          middle           wheel-down       x2
          right

 -- 5 flags: overlay
     Although these should be enums, these are putative flags due to a
     limitation in the implementation(1).  Procs that use them enforce
     enums-ish usage, anyway; a list of symbols results in an error.

          YV12             YVYU             UYVY
          YUY2             IYUV

 -- 2 flags: palette

          logical          physical

 -- 17 flags: video

          sw-surface       no-frame         prealloc
          hw-surface       hw-accel         any-format
          opengl           src-colorkey     hw-palette
          async-blit       rle-accel-ok     doublebuf
          opengl-blit      rle-accel        fullscreen
          resizable        src-alpha

   ---------- Footnotes ----------

   (1) For speed, we use immediate integers (aka "fixnums") for enums,
but those are not wide enough on a 32-bit system to hold the overlay
values.  Probably this should be rectified prior to release as it
represents a semi-regression.  OTOH, it’s not like anyone is actually
using ‘create-yuv-overlay’ anyway…

Appendix B GNU Free Documentation License
*****************************************

                     Version 1.3, 3 November 2008

     Copyright © 2000, 2001, 2002, 2007, 2008 Free Software Foundation, Inc.
     <http://fsf.org/>

     Everyone is permitted to copy and distribute verbatim copies
     of this license document, but changing it is not allowed.

  0. PREAMBLE

     The purpose of this License is to make a manual, textbook, or other
     functional and useful document "free" in the sense of freedom: to
     assure everyone the effective freedom to copy and redistribute it,
     with or without modifying it, either commercially or
     noncommercially.  Secondarily, this License preserves for the
     author and publisher a way to get credit for their work, while not
     being considered responsible for modifications made by others.

     This License is a kind of “copyleft”, which means that derivative
     works of the document must themselves be free in the same sense.
     It complements the GNU General Public License, which is a copyleft
     license designed for free software.

     We have designed this License in order to use it for manuals for
     free software, because free software needs free documentation: a
     free program should come with manuals providing the same freedoms
     that the software does.  But this License is not limited to
     software manuals; it can be used for any textual work, regardless
     of subject matter or whether it is published as a printed book.  We
     recommend this License principally for works whose purpose is
     instruction or reference.

  1. APPLICABILITY AND DEFINITIONS

     This License applies to any manual or other work, in any medium,
     that contains a notice placed by the copyright holder saying it can
     be distributed under the terms of this License.  Such a notice
     grants a world-wide, royalty-free license, unlimited in duration,
     to use that work under the conditions stated herein.  The
     “Document”, below, refers to any such manual or work.  Any member
     of the public is a licensee, and is addressed as “you”.  You accept
     the license if you copy, modify or distribute the work in a way
     requiring permission under copyright law.

     A “Modified Version” of the Document means any work containing the
     Document or a portion of it, either copied verbatim, or with
     modifications and/or translated into another language.

     A “Secondary Section” is a named appendix or a front-matter section
     of the Document that deals exclusively with the relationship of the
     publishers or authors of the Document to the Document’s overall
     subject (or to related matters) and contains nothing that could
     fall directly within that overall subject.  (Thus, if the Document
     is in part a textbook of mathematics, a Secondary Section may not
     explain any mathematics.)  The relationship could be a matter of
     historical connection with the subject or with related matters, or
     of legal, commercial, philosophical, ethical or political position
     regarding them.

     The “Invariant Sections” are certain Secondary Sections whose
     titles are designated, as being those of Invariant Sections, in the
     notice that says that the Document is released under this License.
     If a section does not fit the above definition of Secondary then it
     is not allowed to be designated as Invariant.  The Document may
     contain zero Invariant Sections.  If the Document does not identify
     any Invariant Sections then there are none.

     The “Cover Texts” are certain short passages of text that are
     listed, as Front-Cover Texts or Back-Cover Texts, in the notice
     that says that the Document is released under this License.  A
     Front-Cover Text may be at most 5 words, and a Back-Cover Text may
     be at most 25 words.

     A “Transparent” copy of the Document means a machine-readable copy,
     represented in a format whose specification is available to the
     general public, that is suitable for revising the document
     straightforwardly with generic text editors or (for images composed
     of pixels) generic paint programs or (for drawings) some widely
     available drawing editor, and that is suitable for input to text
     formatters or for automatic translation to a variety of formats
     suitable for input to text formatters.  A copy made in an otherwise
     Transparent file format whose markup, or absence of markup, has
     been arranged to thwart or discourage subsequent modification by
     readers is not Transparent.  An image format is not Transparent if
     used for any substantial amount of text.  A copy that is not
     “Transparent” is called “Opaque”.

     Examples of suitable formats for Transparent copies include plain
     ASCII without markup, Texinfo input format, LaTeX input format,
     SGML or XML using a publicly available DTD, and standard-conforming
     simple HTML, PostScript or PDF designed for human modification.
     Examples of transparent image formats include PNG, XCF and JPG.
     Opaque formats include proprietary formats that can be read and
     edited only by proprietary word processors, SGML or XML for which
     the DTD and/or processing tools are not generally available, and
     the machine-generated HTML, PostScript or PDF produced by some word
     processors for output purposes only.

     The “Title Page” means, for a printed book, the title page itself,
     plus such following pages as are needed to hold, legibly, the
     material this License requires to appear in the title page.  For
     works in formats which do not have any title page as such, “Title
     Page” means the text near the most prominent appearance of the
     work’s title, preceding the beginning of the body of the text.

     The “publisher” means any person or entity that distributes copies
     of the Document to the public.

     A section “Entitled XYZ” means a named subunit of the Document
     whose title either is precisely XYZ or contains XYZ in parentheses
     following text that translates XYZ in another language.  (Here XYZ
     stands for a specific section name mentioned below, such as
     “Acknowledgements”, “Dedications”, “Endorsements”, or “History”.)
     To “Preserve the Title” of such a section when you modify the
     Document means that it remains a section “Entitled XYZ” according
     to this definition.

     The Document may include Warranty Disclaimers next to the notice
     which states that this License applies to the Document.  These
     Warranty Disclaimers are considered to be included by reference in
     this License, but only as regards disclaiming warranties: any other
     implication that these Warranty Disclaimers may have is void and
     has no effect on the meaning of this License.

  2. VERBATIM COPYING

     You may copy and distribute the Document in any medium, either
     commercially or noncommercially, provided that this License, the
     copyright notices, and the license notice saying this License
     applies to the Document are reproduced in all copies, and that you
     add no other conditions whatsoever to those of this License.  You
     may not use technical measures to obstruct or control the reading
     or further copying of the copies you make or distribute.  However,
     you may accept compensation in exchange for copies.  If you
     distribute a large enough number of copies you must also follow the
     conditions in section 3.

     You may also lend copies, under the same conditions stated above,
     and you may publicly display copies.

  3. COPYING IN QUANTITY

     If you publish printed copies (or copies in media that commonly
     have printed covers) of the Document, numbering more than 100, and
     the Document’s license notice requires Cover Texts, you must
     enclose the copies in covers that carry, clearly and legibly, all
     these Cover Texts: Front-Cover Texts on the front cover, and
     Back-Cover Texts on the back cover.  Both covers must also clearly
     and legibly identify you as the publisher of these copies.  The
     front cover must present the full title with all words of the title
     equally prominent and visible.  You may add other material on the
     covers in addition.  Copying with changes limited to the covers, as
     long as they preserve the title of the Document and satisfy these
     conditions, can be treated as verbatim copying in other respects.

     If the required texts for either cover are too voluminous to fit
     legibly, you should put the first ones listed (as many as fit
     reasonably) on the actual cover, and continue the rest onto
     adjacent pages.

     If you publish or distribute Opaque copies of the Document
     numbering more than 100, you must either include a machine-readable
     Transparent copy along with each Opaque copy, or state in or with
     each Opaque copy a computer-network location from which the general
     network-using public has access to download using public-standard
     network protocols a complete Transparent copy of the Document, free
     of added material.  If you use the latter option, you must take
     reasonably prudent steps, when you begin distribution of Opaque
     copies in quantity, to ensure that this Transparent copy will
     remain thus accessible at the stated location until at least one
     year after the last time you distribute an Opaque copy (directly or
     through your agents or retailers) of that edition to the public.

     It is requested, but not required, that you contact the authors of
     the Document well before redistributing any large number of copies,
     to give them a chance to provide you with an updated version of the
     Document.

  4. MODIFICATIONS

     You may copy and distribute a Modified Version of the Document
     under the conditions of sections 2 and 3 above, provided that you
     release the Modified Version under precisely this License, with the
     Modified Version filling the role of the Document, thus licensing
     distribution and modification of the Modified Version to whoever
     possesses a copy of it.  In addition, you must do these things in
     the Modified Version:

       A. Use in the Title Page (and on the covers, if any) a title
          distinct from that of the Document, and from those of previous
          versions (which should, if there were any, be listed in the
          History section of the Document).  You may use the same title
          as a previous version if the original publisher of that
          version gives permission.

       B. List on the Title Page, as authors, one or more persons or
          entities responsible for authorship of the modifications in
          the Modified Version, together with at least five of the
          principal authors of the Document (all of its principal
          authors, if it has fewer than five), unless they release you
          from this requirement.

       C. State on the Title page the name of the publisher of the
          Modified Version, as the publisher.

       D. Preserve all the copyright notices of the Document.

       E. Add an appropriate copyright notice for your modifications
          adjacent to the other copyright notices.

       F. Include, immediately after the copyright notices, a license
          notice giving the public permission to use the Modified
          Version under the terms of this License, in the form shown in
          the Addendum below.

       G. Preserve in that license notice the full lists of Invariant
          Sections and required Cover Texts given in the Document’s
          license notice.

       H. Include an unaltered copy of this License.

       I. Preserve the section Entitled “History”, Preserve its Title,
          and add to it an item stating at least the title, year, new
          authors, and publisher of the Modified Version as given on the
          Title Page.  If there is no section Entitled “History” in the
          Document, create one stating the title, year, authors, and
          publisher of the Document as given on its Title Page, then add
          an item describing the Modified Version as stated in the
          previous sentence.

       J. Preserve the network location, if any, given in the Document
          for public access to a Transparent copy of the Document, and
          likewise the network locations given in the Document for
          previous versions it was based on.  These may be placed in the
          “History” section.  You may omit a network location for a work
          that was published at least four years before the Document
          itself, or if the original publisher of the version it refers
          to gives permission.

       K. For any section Entitled “Acknowledgements” or “Dedications”,
          Preserve the Title of the section, and preserve in the section
          all the substance and tone of each of the contributor
          acknowledgements and/or dedications given therein.

       L. Preserve all the Invariant Sections of the Document, unaltered
          in their text and in their titles.  Section numbers or the
          equivalent are not considered part of the section titles.

       M. Delete any section Entitled “Endorsements”.  Such a section
          may not be included in the Modified Version.

       N. Do not retitle any existing section to be Entitled
          “Endorsements” or to conflict in title with any Invariant
          Section.

       O. Preserve any Warranty Disclaimers.

     If the Modified Version includes new front-matter sections or
     appendices that qualify as Secondary Sections and contain no
     material copied from the Document, you may at your option designate
     some or all of these sections as invariant.  To do this, add their
     titles to the list of Invariant Sections in the Modified Version’s
     license notice.  These titles must be distinct from any other
     section titles.

     You may add a section Entitled “Endorsements”, provided it contains
     nothing but endorsements of your Modified Version by various
     parties—for example, statements of peer review or that the text has
     been approved by an organization as the authoritative definition of
     a standard.

     You may add a passage of up to five words as a Front-Cover Text,
     and a passage of up to 25 words as a Back-Cover Text, to the end of
     the list of Cover Texts in the Modified Version.  Only one passage
     of Front-Cover Text and one of Back-Cover Text may be added by (or
     through arrangements made by) any one entity.  If the Document
     already includes a cover text for the same cover, previously added
     by you or by arrangement made by the same entity you are acting on
     behalf of, you may not add another; but you may replace the old
     one, on explicit permission from the previous publisher that added
     the old one.

     The author(s) and publisher(s) of the Document do not by this
     License give permission to use their names for publicity for or to
     assert or imply endorsement of any Modified Version.

  5. COMBINING DOCUMENTS

     You may combine the Document with other documents released under
     this License, under the terms defined in section 4 above for
     modified versions, provided that you include in the combination all
     of the Invariant Sections of all of the original documents,
     unmodified, and list them all as Invariant Sections of your
     combined work in its license notice, and that you preserve all
     their Warranty Disclaimers.

     The combined work need only contain one copy of this License, and
     multiple identical Invariant Sections may be replaced with a single
     copy.  If there are multiple Invariant Sections with the same name
     but different contents, make the title of each such section unique
     by adding at the end of it, in parentheses, the name of the
     original author or publisher of that section if known, or else a
     unique number.  Make the same adjustment to the section titles in
     the list of Invariant Sections in the license notice of the
     combined work.

     In the combination, you must combine any sections Entitled
     “History” in the various original documents, forming one section
     Entitled “History”; likewise combine any sections Entitled
     “Acknowledgements”, and any sections Entitled “Dedications”.  You
     must delete all sections Entitled “Endorsements.”

  6. COLLECTIONS OF DOCUMENTS

     You may make a collection consisting of the Document and other
     documents released under this License, and replace the individual
     copies of this License in the various documents with a single copy
     that is included in the collection, provided that you follow the
     rules of this License for verbatim copying of each of the documents
     in all other respects.

     You may extract a single document from such a collection, and
     distribute it individually under this License, provided you insert
     a copy of this License into the extracted document, and follow this
     License in all other respects regarding verbatim copying of that
     document.

  7. AGGREGATION WITH INDEPENDENT WORKS

     A compilation of the Document or its derivatives with other
     separate and independent documents or works, in or on a volume of a
     storage or distribution medium, is called an “aggregate” if the
     copyright resulting from the compilation is not used to limit the
     legal rights of the compilation’s users beyond what the individual
     works permit.  When the Document is included in an aggregate, this
     License does not apply to the other works in the aggregate which
     are not themselves derivative works of the Document.

     If the Cover Text requirement of section 3 is applicable to these
     copies of the Document, then if the Document is less than one half
     of the entire aggregate, the Document’s Cover Texts may be placed
     on covers that bracket the Document within the aggregate, or the
     electronic equivalent of covers if the Document is in electronic
     form.  Otherwise they must appear on printed covers that bracket
     the whole aggregate.

  8. TRANSLATION

     Translation is considered a kind of modification, so you may
     distribute translations of the Document under the terms of section
     4.  Replacing Invariant Sections with translations requires special
     permission from their copyright holders, but you may include
     translations of some or all Invariant Sections in addition to the
     original versions of these Invariant Sections.  You may include a
     translation of this License, and all the license notices in the
     Document, and any Warranty Disclaimers, provided that you also
     include the original English version of this License and the
     original versions of those notices and disclaimers.  In case of a
     disagreement between the translation and the original version of
     this License or a notice or disclaimer, the original version will
     prevail.

     If a section in the Document is Entitled “Acknowledgements”,
     “Dedications”, or “History”, the requirement (section 4) to
     Preserve its Title (section 1) will typically require changing the
     actual title.

  9. TERMINATION

     You may not copy, modify, sublicense, or distribute the Document
     except as expressly provided under this License.  Any attempt
     otherwise to copy, modify, sublicense, or distribute it is void,
     and will automatically terminate your rights under this License.

     However, if you cease all violation of this License, then your
     license from a particular copyright holder is reinstated (a)
     provisionally, unless and until the copyright holder explicitly and
     finally terminates your license, and (b) permanently, if the
     copyright holder fails to notify you of the violation by some
     reasonable means prior to 60 days after the cessation.

     Moreover, your license from a particular copyright holder is
     reinstated permanently if the copyright holder notifies you of the
     violation by some reasonable means, this is the first time you have
     received notice of violation of this License (for any work) from
     that copyright holder, and you cure the violation prior to 30 days
     after your receipt of the notice.

     Termination of your rights under this section does not terminate
     the licenses of parties who have received copies or rights from you
     under this License.  If your rights have been terminated and not
     permanently reinstated, receipt of a copy of some or all of the
     same material does not give you any rights to use it.

  10. FUTURE REVISIONS OF THIS LICENSE

     The Free Software Foundation may publish new, revised versions of
     the GNU Free Documentation License from time to time.  Such new
     versions will be similar in spirit to the present version, but may
     differ in detail to address new problems or concerns.  See
     <http://www.gnu.org/copyleft/>.

     Each version of the License is given a distinguishing version
     number.  If the Document specifies that a particular numbered
     version of this License “or any later version” applies to it, you
     have the option of following the terms and conditions either of
     that specified version or of any later version that has been
     published (not as a draft) by the Free Software Foundation.  If the
     Document does not specify a version number of this License, you may
     choose any version ever published (not as a draft) by the Free
     Software Foundation.  If the Document specifies that a proxy can
     decide which future versions of this License can be used, that
     proxy’s public statement of acceptance of a version permanently
     authorizes you to choose that version for the Document.

  11. RELICENSING

     “Massive Multiauthor Collaboration Site” (or “MMC Site”) means any
     World Wide Web server that publishes copyrightable works and also
     provides prominent facilities for anybody to edit those works.  A
     public wiki that anybody can edit is an example of such a server.
     A “Massive Multiauthor Collaboration” (or “MMC”) contained in the
     site means any set of copyrightable works thus published on the MMC
     site.

     “CC-BY-SA” means the Creative Commons Attribution-Share Alike 3.0
     license published by Creative Commons Corporation, a not-for-profit
     corporation with a principal place of business in San Francisco,
     California, as well as future copyleft versions of that license
     published by that same organization.

     “Incorporate” means to publish or republish a Document, in whole or
     in part, as part of another Document.

     An MMC is “eligible for relicensing” if it is licensed under this
     License, and if all works that were first published under this
     License somewhere other than this MMC, and subsequently
     incorporated in whole or in part into the MMC, (1) had no cover
     texts or invariant sections, and (2) were thus incorporated prior
     to November 1, 2008.

     The operator of an MMC Site may republish an MMC contained in the
     site under CC-BY-SA on the same site at any time before August 1,
     2009, provided the MMC is eligible for relicensing.

ADDENDUM: How to use this License for your documents
====================================================

To use this License in a document you have written, include a copy of
the License in the document and put the following copyright and license
notices just after the title page:

       Copyright (C)  YEAR  YOUR NAME.
       Permission is granted to copy, distribute and/or modify this document
       under the terms of the GNU Free Documentation License, Version 1.3
       or any later version published by the Free Software Foundation;
       with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
       Texts.  A copy of the license is included in the section entitled ``GNU
       Free Documentation License''.

If you have Invariant Sections, Front-Cover Texts and Back-Cover Texts,
replace the “with…Texts.” line with this:

         with the Invariant Sections being LIST THEIR TITLES, with
         the Front-Cover Texts being LIST, and with the Back-Cover Texts
         being LIST.

If you have Invariant Sections without Cover Texts, or some other
combination of the three, merge those two alternatives to suit the
situation.

If your document contains nontrivial examples of program code, we
recommend releasing these examples in parallel under your choice of free
software license, such as the GNU General Public License, to permit
their use in free software.

Index
*****

* Menu:

* activity-change:                       Stashes.            (line 2248)
* allocated-channels:                    Audio.              (line 1265)
* alpha-limit:                           Stashes.            (line 2252)
* application-state:                     Stashes.            (line 2256)
* blit-rgba:                             SDL_gfx.            (line 1653)
* blit-surface:                          Video.              (line  652)
* button?:                               Events.             (line 1017)
* call-with-clip-rect:                   Miscellaneous Utilities.
                                                             (line 1760)
* caption-ti:                            Video.              (line  549)
* cd-close:                              CDROM.              (line 1172)
* cd-eject:                              CDROM.              (line 1169)
* cd-get-cur-frame:                      CDROM.              (line 1139)
* cd-get-cur-track:                      CDROM.              (line 1136)
* cd-get-num-tracks:                     CDROM.              (line 1133)
* cd-in-drive?:                          CDROM.              (line 1130)
* cd-msf->frames:                        CDROM.              (line 1175)
* cd-name:                               CDROM.              (line 1116)
* cd-nth-track-itlo:                     CDROM.              (line 1142)
* cd-num-drives:                         CDROM.              (line 1113)
* cd-open:                               CDROM.              (line 1121)
* cd-pause:                              CDROM.              (line 1160)
* cd-play:                               CDROM.              (line 1156)
* cd-play-tracks:                        CDROM.              (line 1147)
* cd-resume:                             CDROM.              (line 1163)
* cd-status:                             CDROM.              (line 1126)
* cd-stop:                               CDROM.              (line 1166)
* cd-track-type:                         Stashes.            (line 2260)
* cd?:                                   CDROM.              (line 1110)
* cdrom-state:                           Stashes.            (line 2264)
* close-audio:                           Audio.              (line 1480)
* color:b:                               Video.              (line  426)
* color:g:                               Video.              (line  423)
* color:r:                               Video.              (line  420)
* color:set-b!:                          Video.              (line  435)
* color:set-g!:                          Video.              (line  432)
* color:set-r!:                          Video.              (line  429)
* color?:                                Video.              (line  414)
* convert-surface:                       Video.              (line  648)
* copy-rectangle:                        Miscellaneous Utilities.
                                                             (line 1825)
* copy-surface:                          Miscellaneous Utilities.
                                                             (line 1845)
* create-cursor:                         Video.              (line  320)
* create-rgb-surface:                    Video.              (line  581)
* create-yuv-overlay:                    Video.              (line  324)
* delay:                                 General SDL.        (line  311)
* device-ffc:                            Audio.              (line 1270)
* display-format:                        Video.              (line  489)
* display-format-alpha:                  Video.              (line  493)
* display-yuv-overlay:                   Video.              (line  528)
* draw-aa-circle:                        SDL_gfx.            (line 1535)
* draw-aa-ellipse:                       SDL_gfx.            (line 1544)
* draw-aa-line:                          SDL_gfx.            (line 1515)
* draw-aa-polygon:                       SDL_gfx.            (line 1567)
* draw-aa-trigon:                        SDL_gfx.            (line 1558)
* draw-arc:                              SDL_gfx.            (line 1523)
* draw-bezier:                           SDL_gfx.            (line 1577)
* draw-character:                        SDL_gfx.            (line 1582)
* draw-circle:                           SDL_gfx.            (line 1531)
* draw-ellipse:                          SDL_gfx.            (line 1539)
* draw-hline:                            SDL_gfx.            (line 1492)
* draw-line:                             SDL_gfx.            (line 1511)
* draw-pie-slice:                        SDL_gfx.            (line 1548)
* draw-point:                            SDL_gfx.            (line 1489)
* draw-polygon:                          SDL_gfx.            (line 1562)
* draw-rectangle:                        SDL_gfx.            (line 1500)
* draw-rounded-rectangle:                SDL_gfx.            (line 1505)
* draw-string:                           SDL_gfx.            (line 1585)
* draw-textured-polygon:                 SDL_gfx.            (line 1572)
* draw-thick-line:                       SDL_gfx.            (line 1519)
* draw-trigon:                           SDL_gfx.            (line 1553)
* draw-vline:                            SDL_gfx.            (line 1496)
* enable-key-repeat:                     Events.             (line  999)
* enable-unicode:                        Events.             (line  994)
* enum->number:                          Enums and Constants.
                                                             (line  215)
* error key ‘non-member-symbol’:         Enums and Constants.
                                                             (line  232)
* event-mask:                            Stashes.            (line 2269)
* event-type:                            Stashes.            (line 2280)
* event-type-handling:                   Events.             (line  989)
* event:active:gain:                     Events.             (line  703)
* event:active:set-gain!:                Events.             (line  710)
* event:active:set-state!:               Events.             (line  713)
* event:active:state:                    Events.             (line  706)
* event:button:button:                   Events.             (line  803)
* event:button:set-button!:              Events.             (line  815)
* event:button:set-state!:               Events.             (line  818)
* event:button:set-x!:                   Events.             (line  821)
* event:button:set-y!:                   Events.             (line  824)
* event:button:state:                    Events.             (line  806)
* event:button:x:                        Events.             (line  809)
* event:button:y:                        Events.             (line  812)
* event:jaxis:axis:                      Events.             (line  846)
* event:jaxis:set-axis!:                 Events.             (line  855)
* event:jaxis:set-value!:                Events.             (line  858)
* event:jaxis:set-which!:                Events.             (line  852)
* event:jaxis:value:                     Events.             (line  849)
* event:jaxis:which:                     Events.             (line  843)
* event:jball:ball:                      Events.             (line  882)
* event:jball:set-ball!:                 Events.             (line  894)
* event:jball:set-which!:                Events.             (line  891)
* event:jball:set-xrel!:                 Events.             (line  897)
* event:jball:set-yrel!:                 Events.             (line  900)
* event:jball:which:                     Events.             (line  879)
* event:jball:xrel:                      Events.             (line  885)
* event:jball:yrel:                      Events.             (line  888)
* event:jbutton:button:                  Events.             (line  864)
* event:jbutton:set-button!:             Events.             (line  873)
* event:jbutton:set-state!:              Events.             (line  876)
* event:jbutton:set-which!:              Events.             (line  870)
* event:jbutton:state:                   Events.             (line  867)
* event:jbutton:which:                   Events.             (line  861)
* event:jhat:hat:                        Events.             (line  906)
* event:jhat:set-hat!:                   Events.             (line  916)
* event:jhat:set-value!:                 Events.             (line  919)
* event:jhat:set-which!:                 Events.             (line  913)
* event:jhat:value:                      Events.             (line  909)
* event:jhat:which:                      Events.             (line  903)
* event:key:keysym:mod:                  Events.             (line  729)
* event:key:keysym:scancode:             Events.             (line  740)
* event:key:keysym:set-mod!:             Events.             (line  733)
* event:key:keysym:set-scancode!:        Events.             (line  749)
* event:key:keysym:set-sym!:             Events.             (line  726)
* event:key:keysym:set-unicode!:         Events.             (line  752)
* event:key:keysym:sym:                  Events.             (line  723)
* event:key:keysym:unicode:              Events.             (line  743)
* event:key:set-state!:                  Events.             (line  746)
* event:key:state:                       Events.             (line  737)
* event:motion:set-state!:               Events.             (line  774)
* event:motion:set-x!:                   Events.             (line  778)
* event:motion:set-xrel!:                Events.             (line  784)
* event:motion:set-y!:                   Events.             (line  781)
* event:motion:set-yrel!:                Events.             (line  787)
* event:motion:state:                    Events.             (line  758)
* event:motion:x:                        Events.             (line  762)
* event:motion:xrel:                     Events.             (line  768)
* event:motion:y:                        Events.             (line  765)
* event:motion:yrel:                     Events.             (line  771)
* event:resize:h:                        Events.             (line  929)
* event:resize:set-h!:                   Events.             (line  935)
* event:resize:set-w!:                   Events.             (line  932)
* event:resize:w:                        Events.             (line  926)
* event:set-type!:                       Events.             (line  690)
* event:type:                            Events.             (line  687)
* evqueue-add:                           Events.             (line  944)
* evqueue-get:                           Events.             (line  956)
* evqueue-peek:                          Events.             (line  948)
* exact-truncate:                        Miscellaneous Utilities.
                                                             (line 1749)
* expire-channel:                        Audio.              (line 1359)
* fade-out-channel:                      Audio.              (line 1365)
* fade-out-group:                        Audio.              (line 1371)
* fade-out-music:                        Audio.              (line 1377)
* fader/3p:                              Miscellaneous Utilities.
                                                             (line 1871)
* fading-channel:                        Audio.              (line 1386)
* fading-music:                          Audio.              (line 1382)
* fading-status:                         Stashes.            (line 2290)
* fill-rect:                             Video.              (line  485)
* flags->number:                         Enums and Constants.
                                                             (line  222)
* flip:                                  Video.              (line  407)
* font-rotation:                         Stashes.            (line 2294)
* font-rotation!:                        SDL_gfx.            (line 1588)
* font-style:                            Stashes.            (line 2299)
* font:ascent:                           TrueType.           (line 1210)
* font:descent:                          TrueType.           (line 1214)
* font:glyph-xXyYa:                      TrueType.           (line 1221)
* font:height:                           TrueType.           (line 1207)
* font:line-skip:                        TrueType.           (line 1218)
* font:set-style!:                       TrueType.           (line 1202)
* font:style:                            TrueType.           (line 1197)
* fps-manager-delay!:                    SDL_gfx.            (line 1642)
* fps-manager-get:                       SDL_gfx.            (line 1638)
* fps-manager-set!:                      SDL_gfx.            (line 1634)
* frames-msf:                            CDROM.              (line 1179)
* get-app-state:                         Video.              (line  569)
* get-clip-rect:                         Video.              (line  645)
* get-cursor:                            Video.              (line  503)
* get-error:                             General SDL.        (line  314)
* get-event-filter:                      Events.             (line  983)
* get-gamma-ramp:                        Video.              (line  453)
* get-key-state:                         Events.             (line 1006)
* get-mod-state:                         Events.             (line 1009)
* get-ticks:                             General SDL.        (line  307)
* get-video-surface:                     Video.              (line  329)
* get-wm-info:                           Video.              (line  535)
* gl-get-attribute:                      Video.              (line  512)
* gl-set-attribute:                      Video.              (line  515)
* gl-swap-buffers:                       Video.              (line  519)
* grab-input:                            Video.              (line  564)
* grab-mode:                             Stashes.            (line 2304)
* group-available:                       Audio.              (line 1300)
* group-channel:                         Audio.              (line 1289)
* group-channels:                        Audio.              (line 1295)
* group-count:                           Audio.              (line 1304)
* group-newer:                           Audio.              (line 1312)
* group-oldest:                          Audio.              (line 1308)
* halt-channel:                          Audio.              (line 1348)
* halt-group:                            Audio.              (line 1352)
* halt-music:                            Audio.              (line 1356)
* horizontal-flip-surface:               Video.              (line  664)
* iconify-window:                        Video.              (line  556)
* ignore-all-event-types-except:         Miscellaneous Utilities.
                                                             (line 1852)
* imfi-abs-diff:                         SDL_gfx.            (line 1677)
* imfi-add:                              SDL_gfx.            (line 1668)
* imfi-add-c:                            SDL_gfx.            (line 1704)
* imfi-add-c-to-half:                    SDL_gfx.            (line 1707)
* imfi-ashl:                             SDL_gfx.            (line 1731)
* imfi-ashr:                             SDL_gfx.            (line 1713)
* imfi-ashr-mul-c:                       SDL_gfx.            (line 1722)
* imfi-binarize:                         SDL_gfx.            (line 1734)
* imfi-bshl:                             SDL_gfx.            (line 1725)
* imfi-clip:                             SDL_gfx.            (line 1737)
* imfi-div:                              SDL_gfx.            (line 1698)
* imfi-logand:                           SDL_gfx.            (line 1692)
* imfi-logior:                           SDL_gfx.            (line 1695)
* imfi-lshl:                             SDL_gfx.            (line 1728)
* imfi-lshr:                             SDL_gfx.            (line 1716)
* imfi-mean:                             SDL_gfx.            (line 1671)
* imfi-mmx?:                             SDL_gfx.            (line 1663)
* imfi-mul-c:                            SDL_gfx.            (line 1719)
* imfi-muldiv2:                          SDL_gfx.            (line 1686)
* imfi-muldiv4:                          SDL_gfx.            (line 1689)
* imfi-mulnor:                           SDL_gfx.            (line 1683)
* imfi-mult:                             SDL_gfx.            (line 1680)
* imfi-normalize-linear:                 SDL_gfx.            (line 1740)
* imfi-not:                              SDL_gfx.            (line 1701)
* imfi-sub:                              SDL_gfx.            (line 1674)
* imfi-sub-c:                            SDL_gfx.            (line 1710)
* init:                                  General SDL.        (line  287)
* init <1>:                              Stashes.            (line 2308)
* init-subsystem:                        General SDL.        (line  291)
* joystick-ball-xy:                      Joystick.           (line 1093)
* joystick-close:                        Joystick.           (line 1104)
* joystick-get-axis:                     Joystick.           (line 1090)
* joystick-get-button:                   Joystick.           (line 1100)
* joystick-get-hat:                      Joystick.           (line 1097)
* joystick-hat-position:                 Stashes.            (line 2314)
* joystick-index:                        Joystick.           (line 1066)
* joystick-name:                         Joystick.           (line 1054)
* joystick-num-axes:                     Joystick.           (line 1069)
* joystick-num-balls:                    Joystick.           (line 1072)
* joystick-num-buttons:                  Joystick.           (line 1078)
* joystick-num-hats:                     Joystick.           (line 1075)
* joystick-open:                         Joystick.           (line 1058)
* joystick-opened?:                      Joystick.           (line 1062)
* joystick-polling:                      Joystick.           (line 1084)
* joystick-update:                       Joystick.           (line 1081)
* joystick?:                             Joystick.           (line 1051)
* keyboard-modifier:                     Stashes.            (line 2319)
* keyboard/button-state:                 Stashes.            (line 2326)
* keysym:                                Stashes.            (line 2330)
* kotk:                                  Enums and Constants.
                                                             (line  204)
* list-modes:                            Video.              (line  346)
* load-bmp:                              Video.              (line  612)
* load-font:                             TrueType.           (line 1194)
* load-image:                            Video.              (line  616)
* load-music:                            Audio.              (line 1275)
* load-wave:                             Audio.              (line 1279)
* lock-surface:                          Video.              (line  606)
* lock-yuv-overlay:                      Video.              (line  522)
* make-color:                            Video.              (line  417)
* make-event:                            Events.             (line  683)
* make-fps-manager:                      SDL_gfx.            (line 1628)
* make-rect:                             Video.              (line  370)
* make-surface:                          Video.              (line  576)
* map-rgb:                               Video.              (line  465)
* map-rgba:                              Video.              (line  471)
* mouse-button:                          Stashes.            (line 2377)
* mouse-button <1>:                      Stashes.            (line 2383)
* mouse-bxy:                             Events.             (line 1036)
* music-volume:                          Audio.              (line 1344)
* ‘non-member-symbol’, error key:        Enums and Constants.
                                                             (line  232)
* num-joysticks:                         Joystick.           (line 1048)
* number->enum:                          Enums and Constants.
                                                             (line  218)
* number->flags:                         Enums and Constants.
                                                             (line  227)
* open-audio:                            Audio.              (line 1260)
* overlay:                               Stashes.            (line 2389)
* palette:                               Stashes.            (line 2397)
* pause:                                 Audio.              (line 1391)
* pause-music:                           Audio.              (line 1403)
* paused-music?:                         Audio.              (line 1412)
* paused?:                               Audio.              (line 1399)
* pixel-rgb:                             Video.              (line  477)
* pixel-rgba:                            Video.              (line  481)
* play-channel:                          Audio.              (line 1316)
* play-music:                            Audio.              (line 1325)
* playing-music?:                        Audio.              (line 1419)
* playing?:                              Audio.              (line 1415)
* poll-event:                            Events.             (line  963)
* poll-with-push-on-timeout-proc:        Miscellaneous Utilities.
                                                             (line 1804)
* pump-events:                           Events.             (line  941)
* push-event:                            Events.             (line  973)
* quit:                                  General SDL.        (line  295)
* quit-subsystem:                        General SDL.        (line  298)
* rect:h:                                Video.              (line  383)
* rect:set-h!:                           Video.              (line  395)
* rect:set-w!:                           Video.              (line  392)
* rect:set-x!:                           Video.              (line  386)
* rect:set-y!:                           Video.              (line  389)
* rect:w:                                Video.              (line  380)
* rect:x:                                Video.              (line  374)
* rect:y:                                Video.              (line  377)
* rect<-surface:                         Miscellaneous Utilities.
                                                             (line 1819)
* rect?:                                 Video.              (line  367)
* rectangle-closure:                     Miscellaneous Utilities.
                                                             (line 1768)
* rectangle<-geometry-string:            Miscellaneous Utilities.
                                                             (line 1780)
* render-glyph:                          TrueType.           (line 1248)
* render-text:                           TrueType.           (line 1236)
* render-utf8:                           TrueType.           (line 1242)
* reserve-channels:                      Audio.              (line 1283)
* resume:                                Audio.              (line 1395)
* resume-music:                          Audio.              (line 1406)
* rewind-music:                          Audio.              (line 1409)
* rotate-square:                         Miscellaneous Utilities.
                                                             (line 1764)
* roto-zoom-surface:                     SDL_gfx.            (line 1600)
* roto-zoom-surface-xy:                  SDL_gfx.            (line 1605)
* ‘s16’:                                 Uniform Vectors.    (line  252)
* save-bmp:                              Video.              (line  620)
* set-caption:                           Video.              (line  544)
* set-clip-rect!:                        Video.              (line  640)
* set-colors!:                           Video.              (line  438)
* set-cursor:                            Video.              (line  500)
* set-distance:                          Audio.              (line 1440)
* set-event-filter:                      Events.             (line  976)
* set-gamma:                             Video.              (line  449)
* set-gamma-ramp:                        Video.              (line  459)
* set-icon:                              Video.              (line  553)
* set-mod-state:                         Events.             (line 1012)
* set-music-command:                     Audio.              (line 1422)
* set-palette:                           Video.              (line  443)
* set-panning:                           Audio.              (line 1434)
* set-pixel-alpha!:                      SDL_gfx.            (line 1648)
* set-position:                          Audio.              (line 1456)
* set-video-mode:                        Video.              (line  359)
* show-cursor:                           Video.              (line  506)
* shrink-surface:                        SDL_gfx.            (line 1617)
* simple-canvas:                         Simple Closures.    (line 1939)
* simple-stylus:                         Simple Closures.    (line 1970)
* simple-vpacked-image:                  Simple Closures.    (line 1996)
* surface-alpha!:                        Video.              (line  632)
* surface-color-key!:                    Video.              (line  624)
* surface-get-format:                    Video.              (line  600)
* surface-pixels:                        Video.              (line  671)
* surface:depth:                         Video.              (line  594)
* surface:flags:                         Video.              (line  597)
* surface:h:                             Video.              (line  591)
* surface:w:                             Video.              (line  588)
* surface?:                              Video.              (line  603)
* text-wh:                               TrueType.           (line 1226)
* toggle-full-screen:                    Video.              (line  559)
* toroidal-panner/3p:                    Miscellaneous Utilities.
                                                             (line 1886)
* ttf-init:                              TrueType.           (line 1191)
* ttf-quit:                              TrueType.           (line 1254)
* ‘u16’:                                 Uniform Vectors.    (line  252)
* ‘u8’:                                  Uniform Vectors.    (line  252)
* uniform vector argument(s):            Uniform Vectors.    (line  252)
* unlock-surface:                        Video.              (line  609)
* unlock-yuv-overlay:                    Video.              (line  525)
* update-rect:                           Video.              (line  398)
* update-rects:                          Video.              (line  404)
* utf8-wh:                               TrueType.           (line 1231)
* vertical-flip-surface:                 Video.              (line  661)
* vh-flip-surface:                       Video.              (line  667)
* video:                                 Stashes.            (line 2401)
* video-cmf:                             Video.              (line  332)
* video-driver-name:                     Video.              (line  343)
* video-mode-ok:                         Video.              (line  352)
* volume:                                Audio.              (line 1329)
* wait-event:                            Events.             (line  968)
* warp-mouse:                            Video.              (line  497)
* was-init:                              General SDL.        (line  302)
* zoom-surface:                          SDL_gfx.            (line 1612)

